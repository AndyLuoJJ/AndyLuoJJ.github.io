<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://AndyLuoJJ.github.io</id>
    <title>Andy的小书架</title>
    <updated>2019-09-13T10:04:00.028Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://AndyLuoJJ.github.io"/>
    <link rel="self" href="https://AndyLuoJJ.github.io/atom.xml"/>
    <subtitle>这是我的个人博客，希望能够坚持写一下自己各方面的心得😃</subtitle>
    <logo>https://AndyLuoJJ.github.io/images/avatar.png</logo>
    <icon>https://AndyLuoJJ.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Andy的小书架</rights>
    <entry>
        <title type="html"><![CDATA[macOS 使用 pyenv 和 virtualenv 搭建 python 工作环境]]></title>
        <id>https://AndyLuoJJ.github.io/post/macos-shi-yong-pyenv-he-virtualenv-da-jian-python-gong-zuo-huan-jing</id>
        <link href="https://AndyLuoJJ.github.io/post/macos-shi-yong-pyenv-he-virtualenv-da-jian-python-gong-zuo-huan-jing">
        </link>
        <updated>2019-09-13T09:53:13.000Z</updated>
        <summary type="html"><![CDATA[<p>人生苦短，我在 Mac 上用 python。</p>
]]></summary>
        <content type="html"><![CDATA[<p>人生苦短，我在 Mac 上用 python。</p>
<!-- more -->
<h2 id="介绍">介绍</h2>
<p>macOS 自带 python2.7，但是为了更好地进行 python 的开发，最好是安装 python3 进行适配。然而，有时候我们需要在不同的项目中使用不同版本的 python，如果直接采用官网的 pkg 文件安装的话不免会产生冲突，而且也没有办法管理。为此，本文通过使用 Homebrew 和相应的工具包来搭建 python 工作环境。</p>
<blockquote>
<p>注：对于 Linux 平台，同样也可以使用 pyenv 和 virtualenv 对不同版本的 python 和不同的开发环境进行管理，命令基本相同，只是在安装 pyenv 的时候就没办法使用 Homebrew 了，可以使用 Linux 平台上的 apt-get 等包管理工具进行安装。</p>
</blockquote>
<h2 id="准备工作">准备工作</h2>
<ol>
<li>安装 Homebrew</li>
<li>了解如何使用 Terminal</li>
</ol>
<h2 id="使用-pyenv-安装-管理多版本-python">使用 pyenv 安装、管理多版本 python</h2>
<p>pyenv 提供了一个安装、管理多个版本的 python 的工具，可以用类似于 Homebrew 安装包的语句来安装、管理不同版本的 python。</p>
<h3 id="安装-pyenv">安装 pyenv</h3>
<p>安装好 Homebrew 以后，执行<code>brew install pyenv</code>即可完成 pyenv 的安装。<br>
若要卸载 pyenv，执行<code>brew uninstall pyenv</code>即可<br>
安装完成后，还需要在 .bash_profile 中增加以下内容：</p>
<pre><code>export PYENV_ROOT=&quot;${HOME}/.pyenv&quot;

if [ -d &quot;${PYENV_ROOT}&quot; ]; then
  export PATH=&quot;${PYENV_ROOT}/bin:${PATH}&quot;
  eval &quot;$(pyenv init -)&quot;
fi
</code></pre>
<p>这段代码的作用主要是指明 pyenv 的位置， 以便以后可以直接在命令行里面运行 pyenv 命令。 保存在 ~/.bash_profile 文件中是为了每次用户登陆后自动生效。</p>
<h3 id="安装-卸载-python">安装、卸载 python</h3>
<p>完成 pyenv 的安装后，执行<code>pyenv install (python-version)</code>即可安装对应版本号的 python。可通过命令<code>pyenv install --list</code>查看所有可安装的 python 版本，然后替换前面的<code>(python-version)</code>即可。<br>
安装完毕后，执行<code>pyenv version</code>查看当前 python 版本。<code>pyenv versions</code>查看已安装的 python 版本，前面有星号的表示当前 python 版本<br>
安装好的 python 实际路径为<code>~/.pyenv/versions</code></p>
<h3 id="切换-python-版本">切换 python 版本</h3>
<p>使用<code>pyenv global (python-version)</code>切换全局 python 版本，<code>pyenv global system</code>切换回系统自带 python，<code>pyenv local (python-version)</code>切换当前目录的 python 版本。</p>
<h2 id="使用-pyenv-virtualenv-创建-管理多个不同的-python-工作区">使用 pyenv-virtualenv 创建、管理多个不同的 python 工作区</h2>
<p>有时候我们需要在不同的项目工程中使用不同版本的 python，virtualenv 就是一个能够创建隔离的 python 环境的工具，这本来是一个 python 包，本节将介绍一个基于 pyenv 的插件：pyenv-virtualenv。下一节介绍如何单独使用 virtualenv 管理工作区。</p>
<h3 id="安装-pyenv-virtualenv">安装 pyenv-virtualenv</h3>
<p>使用 Homebrew 安装：<code>brew install pyenv-virtualenv</code></p>
<h3 id="创建隔离的工作环境">创建隔离的工作环境</h3>
<p>创建工作环境：<code>pyenv virtualenv (python-version) (workspace-name)</code>。<br>
上面这句命令使用给定的python版本创建了一个名为workspace-name的工作环境，目录的实际路径为<code>~/.pyenv/versions/(python-version)/envs</code>，同时会在<code>~/.pyenv/versions</code>中创建一个对应的软链接，指向相应的目录。</p>
<h3 id="切换不同的工作环境">切换不同的工作环境</h3>
<p>激活环境：<code>pyenv activate (workspace-name)</code><br>
退出环境：<code>pyenv deactivate</code><br>
在这个隔离的虚拟环境中，可以使用 pip 安装需要的包，而不会影响到其他的 python 版本。但是可能会在 home directory 下创建一些隐藏目录（如 keras、matplotlib、jupyter 等）。</p>
<h3 id="删除工作环境">删除工作环境</h3>
<p>只需要把工作环境的目录删除掉就可以删除对应的工作环境了</p>
<blockquote>
<p>顺带一提的是，使用 PyCharm 等 IDE 的时候，会自动检测出项目是否使用了 virtualenv ，因此直接在 IDE 中运行代码即可，不需要激活虚拟环境。</p>
</blockquote>
<h2 id="单独使用-virtualenv-管理工作区">单独使用 virtualenv 管理工作区</h2>
<p>virtualenv 原本是一个可以通过 pip 安装的 python 包，上面的 pyenv-virtualenv 是以插件的形式，配合 pyenv 进行使用的。如果已经用其他的方法安装了 python，如官网 pkg、Homebrew 等，还可以单独使用 virtualenv 进行管理。效果与前面完全相同，只是使用的命令有所改变。</p>
<h3 id="安装-virtualenv">安装 virtualenv</h3>
<p>使用 pip 安装：<code>pip install virtualenv</code></p>
<h3 id="创建隔离的工作环境-2">创建隔离的工作环境</h3>
<p>创建工作环境：<code>virtualenv (python-path) (workspace-directory) --option</code><br>
上述命令中，需要指定工作环境使用 python 的 python 解释器路径，然后会复制一份到工作环境中，并且还需要指定工作环境的实际路径；option 选项则可以指定是否将原来的包一并复制过去，如果使用<code>--no-site-packages</code>则不复制,<code>pyenv global (python-version)</code> 仅复制系统系统包，默认是复制的。</p>
<h3 id="切换工作环境">切换工作环境</h3>
<p>首先 cd 到 workspace-directory。<br>
激活环境：<code>source bin/activate</code><br>
退出环境：<code>deactivate</code><br>
激活后就可以在隔离的工作环境中使用 pip 安装需要的包了。</p>
<h3 id="删除隔离的工作环境">删除隔离的工作环境</h3>
<p>同样是删除 workspace-directory 即可删除工作环境。</p>
<h2 id="总结">总结</h2>
<p>说了这么多，使用这种办法来安装和管理无非是为了能够更好地掌控安装过程，并且安装、卸载也非常干净简洁。在搭建好 python 工作环境以后，马上开始着手干活才是最重要的，不能为了使用工具而使用工具，这样就本末倒置了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift Package Manager - Swift自带的包管理器]]></title>
        <id>https://AndyLuoJJ.github.io/post/swift-package-manager-swift-zi-dai-de-bao-guan-li-qi</id>
        <link href="https://AndyLuoJJ.github.io/post/swift-package-manager-swift-zi-dai-de-bao-guan-li-qi">
        </link>
        <updated>2019-09-13T09:41:12.000Z</updated>
        <summary type="html"><![CDATA[<p>WWDC19 为 Swift 带来了新的活力 - Swift Package Manager 将促使 Swift 向其他领域的发展迈出重要的一步。</p>
]]></summary>
        <content type="html"><![CDATA[<p>WWDC19 为 Swift 带来了新的活力 - Swift Package Manager 将促使 Swift 向其他领域的发展迈出重要的一步。</p>
<!-- more -->
<p>为了能够更方便地通过 Swift 创建可执行文件及第三方库，Apple 提供了 Swift Package Manager 来帮助开发人员管理项目，以便复用代码及简化管理流程。</p>
<h3 id="相关概念">相关概念</h3>
<h4 id="package">Package</h4>
<p>Package 包含一系列的 Swift 源文件和一个名为<code>Package.swift</code>的配置文件。配置文件中定义了Package 的名称和内容。一个 Package 可以产生多个 target，而每个 target 唯一对应一个 product 及一个或以上的 dependency。</p>
<p>Target 是 Package 产生的目标，一个 Package 可以有多个目标。每个 Target 都产生一个输出，这个输出可以是空的、可执行文件、库、系统模块，并且每个 target 都可以是基于其他的库进行开发的，这些库就称为这个target 的依赖（dependency）。</p>
<h4 id="module">Module</h4>
<p>Swift 将 Package 中的文件以 module（模块）的形式进行管理，每一个 module 都规定了一个命名空间（namespace），并且通过访问控制符，可以控制 module 内部的代码是否可以被 module 外的代码所访问。</p>
<p>每一个工程都可以将它需要用到的代码全部包含到一个 module 中，也可以将其他的 module 导入（import）进来，作为自己的依赖（dependency）。<strong>注意 target 的依赖和工程的依赖稍有不同，所有 target 的依赖构成的集合才是工程的依赖。</strong></p>
<p>通过将能够解决某一特定类型的问题的代码封装成一个独立的模块，可以使代码复用到其他场景中。例如，用于解析JSON数据的模块可以用到所有需要与网络数据打交道的项目中，这样就不需要重新自己写相应功能的代码了。<strong>对这类代码的要求是必须独立于项目之外，具有类似于函数的特性。</strong></p>
<p>SPM 允许我们从本地或者网络上获取到我们所需要的其他第三方 module。</p>
<h4 id="library">Library</h4>
<p>Library 类似于开发中的库，即工程本身不产生可执行文件，而是作用一个通用的功能模块，可以被导入到其他项目中发挥作用。</p>
<h4 id="dependency">Dependency</h4>
<p>如果想要能够复用代码，就需要指定自己的工程<em>依赖</em>于哪些外部的代码，因为自己的工程能否正常运行取决于这些外部代码是否正常工作，因此这些外部代码也被称为依赖（dependency）。</p>
<h3 id="简单使用方法">简单使用方法</h3>
<p>下面简单介绍一下SPM的使用方法。</p>
<h4 id="创建项目">创建项目</h4>
<p>在需要创建项目的目录中执行<code>swift package init</code>以创建一个新的 Swift 项目。</p>
<pre><code>$ mkdir testProgram
$ cd testProgram
$ swift package init (--type library/executable/empty/system module)
</code></pre>
<p>type可以有四种类型：</p>
<ul>
<li>library: 创建库</li>
<li>executable: 创建可执行文件</li>
<li>empty:创建空项目</li>
<li>system module:创建系统模块项目<br>
默认创建的是library。</li>
</ul>
<p>另外，在创建好项目后，为了能够充分发挥Xcode强大的功能，还可以生成 Xcode project 以便在 Xcode 中编辑、调试代码。cd 到项目目录后，执行<code>swift package generate-xcodeproj</code>就可以创建对应的 Xcode project 了。</p>
<blockquote>
<p>目前只能在 Xcode 中实现代码编辑，暂时没有找到能够充分发挥 Xcode 功能的办法，编译和运行都需要回到 Terminal 进行。</p>
</blockquote>
<h4 id="添加外部模块">添加外部模块</h4>
<p>如前所述，<code>Package.swift</code>是项目的配置文件，模版代码如下。</p>
<pre><code class="language-swift">// swift-tools-version:4.2
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: &quot;testProgram&quot;,
    products: [
        // Products define the executables and libraries produced by a package, and make them visible to other packages.
        // A package can produce multiple executables and libraries.
        .library(
            name: &quot;testProgram&quot;,
            targets: [&quot;testProgram&quot;]),
        .executable(
            name: &quot;MainExecutable&quot;,
            targets: [&quot;MainExecutable&quot;])
    ],
    dependencies: [
        // Dependencies declare other packages that this package depends on.
        // .package(url: /* package url */, from: &quot;1.0.0&quot;),
    ],
    targets: [
        // Targets are the basic building blocks of a package. A target can define a module or a test suite, and of course an executable.
        // Targets can depend on other targets in this package, and on products in packages which this package depends on.
        .target(
            name: &quot;testProgram&quot;,
            dependencies: []),
        .testTarget(
            name: &quot;testProgramTests&quot;,
            dependencies: [&quot;testProgram&quot;]),
    ]
)

</code></pre>
<p>该模版代码创建了一个Package实例，并通过构造参数来指定项目的name、product、target和dependency。各字段作用如下：</p>
<ul>
<li>name:指定项目名称</li>
<li>products:指定项目生成的东西，可以是library或者executable，同一个项目可以生成多个library或executable。</li>
<li>dependencies: 指定项目所使用的依赖库及其URL、版本等信息。</li>
<li>targets:指定项目生成的目标，</li>
</ul>
<p>若要添加开源代码，在.dependency中添加：</p>
<pre><code class="language-swift">.package(url: &quot;open source url&quot;, from: &quot;version number&quot;)
</code></pre>
<p>若要添加本地依赖，在.dependency中添加：</p>
<pre><code class="language-swift">.package(path:&quot;local path&quot;)
</code></pre>
<p>可以添加多个依赖，并且用上述类似的方法还可以创建多个products和targets。</p>
<p>然后在产生的targets中，指定对应的dependency的名称就可以了。</p>
<h4 id="发布library">发布library</h4>
<p>使用Git将自己创建好的library发布到托管仓库中。</p>
<pre><code>$ git init  // create a new git project
$ git add . // add all files to the stack
$ git remote add origin [github-URL] // add a remote origin in the remote repository
$ git commit -m &quot;Initial Commit&quot; // commit all files in the stack to local repository
$ git tag 1.0.0 // tag the branch
$ git push origin master --tags // push local repository to remote repository
</code></pre>
<p>tag标记的版本号就是其他项目将本项目作为依赖时引用的版本号（from）。对于本地依赖，虽然可以借助git的本地仓库回溯功能进行代码管理，但是在Swift Package Manager中暂时不支持引用本地依赖的版本号。</p>
<h4 id="更新依赖包">更新依赖包</h4>
<p>编辑<code>Package.swift</code>中依赖包的版本信息，然后执行<code>swift package update</code>即可更新需要的依赖包。</p>
<h4 id="创建模块">创建模块</h4>
<p>只需要将<code>Package.swift</code>中的products添加.library就可以创建模块了。每一个Package可以产生多个library，不同的library在Sources目录下以不同名称的目录呈现。</p>
<p>如果生成的library之间有相互关联，则需要在完成一个library的编码工作后，先执行<code>swift build</code>对已有的library进行编译，然后再进行下一个library的编码工作。这有助于以模块化的方式完成library的创建。</p>
<p>注意：对于使用Git开源的代码，需要打上git tag，别人才能够导入对应版本的代码。同样地，对于本地依赖，最好也加上git tag，但是应该不是必须的。</p>
<h3 id="实例结合使用swift-for-tensorflow和swift-package-manager">实例——结合使用Swift for TensorFlow和Swift Package Manager</h3>
<p>为了能够同时使用Swift for TensorFlow和Swift Package Manager进行Swift机器学习项目的管理（个人认为这是比较通用的方法），需要先指定swift路径为SFT的路径，然后使用SPM对项目进行编译、运行等处理。下面macOS上的SFT和SPM为例介绍如何结合使用两者。</p>
<ol>
<li>指定swift路径<br>
在<code>$PATH</code>中指定swift的路径。由于使用了Swift for TensorFLow，因此需要到GitHub仓库中下载对应的swift toolchain，链接<a href="https://github.com/tensorflow/swift">在这里</a>。该swift toolchain中包含了完整的swift编译器，与Xcode自带的toolchain相比多了能够使用TensorFlow的功能。</li>
</ol>
<blockquote>
<p>如果在Linux下进行开发，还需要事先配置好swift的环境，具体教程<a href="https://swift.org/getting-started/">见这里</a>。</p>
</blockquote>
<ol start="2">
<li>创建model对应的library<br>
由于机器学习模型是比较独立的部分，因此最好将其作为一个独立的module，然后将其导入到其他项目中去。接下来要做的创建ML model对应的library。</li>
</ol>
<p>由于例子中MLModel没有使用到第三方库，因此配置文件不需要修改。在<code>./Sources/name</code>中就包含了一个本地module，修改代码为:</p>
<pre><code class="language-swift">import TensorFlow

struct MLPClassifier {
    var w1 = Tensor&lt;Float&gt;(shape: [2, 4], repeating: 0.1)
    var w2 = Tensor&lt;Float&gt;(shape: [4, 1], scalars: [0.4, -0.5, -0.5, 0.4])
    var b1 = Tensor&lt;Float&gt;([0.2, -0.3, -0.3, 0.2])
    var b2 = Tensor&lt;Float&gt;([[0.4]])

    func prediction(`for` x: Tensor&lt;Float&gt;) -&gt; Tensor&lt;Float&gt; {
        let o1 = tanh(matmul(x, w1) + b1)
        return tanh(matmul(o1, w2) + b2)
    }
}
</code></pre>
<p>这里用一个简单的MLP模型作为例子进行展示，自定义了一个MLPClassifierd的类，定义了第一层及第二层的权重和bias，然后使用tanh作为activation function，得到“网络”输出的结果。<br>
通过上述代码就完成了ML model的创建，可以运行swift build看看有没有问题。</p>
<blockquote>
<p>为了加速模型的计算，会有warning说没有用optimization编译。对于小网络来说影响不大，但如果网络结构比较复杂的时候可能会导致训练过慢。暂时好像没有什么办法，唯一想到的解决方案是在release模式下编译，即<code>swift build -c release</code>，release模式默认使用-O进行编译。</p>
</blockquote>
<ol start="3">
<li>创建swift项目<br>
接下来创建使用前面建立好的module的swift项目。新建一个executable的项目，并在Package.swift中添加本地依赖MLModel和用于测试的第三方库SwiftyJSON。</li>
</ol>
<p>测试代码如下：</p>
<pre><code class="language-swift">import TensorFlow
import MLModel

let input = Tensor&lt;Float&gt;([[0.2, 0.8]])
let classifier = MLPClassifier()
let prediction = classifier.prediction(for: input)
print(prediction)
</code></pre>
<p>⚠️：SwiftyJSON要求toolchain版本在4以上，而Swift for TensorFlow的toolchain版本为3，因此暂时没有办法同时使用这两个框架。</p>
<ol start="4">
<li>编译运行<br>
尝试进行编译运行。可以分别执行编译和运行两个步骤，也可以直接运行观察代码运行结果。<br>
编译项目：</li>
</ol>
<pre><code>swift build
</code></pre>
<p>默认的编译环境是<code>debug</code>，可通过<code>-c release</code>的标记，将编译环境切换到<code>release</code>。debug模式默认不开启-O优化，因此为了使Swift for TensorFlow获得最佳性能，建议先在release模式下编译项目，再到指定目录执行link生成的可执行文件。</p>
<p>运行项目：</p>
<pre><code>swift run (executable name)
</code></pre>
<p>也可以找到build生成的可执行文件，然后直接执行。</p>
<blockquote>
<p>如果项目中存在多个可执行文件，需要在<code>swift run</code>命令后增加对应的可执行文件的名称。利用这一特性可以将多个独立的工程汇总在一个package下面，便于管理，但是一个不好的地方是如果修改了一个地方就必须把当前package下的所有swift源文件编译一遍。目前的解决方法是当package规模扩大后，将其中一部分相对独立的功能打包成新的swift package，然后导入进来，这样就不用重新编译导入进来的源码了。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Homebrew - macOS 上完美的包管理器]]></title>
        <id>https://AndyLuoJJ.github.io/post/homebrew-macos-shang-wan-mei-de-bao-guan-li-qi</id>
        <link href="https://AndyLuoJJ.github.io/post/homebrew-macos-shang-wan-mei-de-bao-guan-li-qi">
        </link>
        <updated>2019-09-13T09:15:33.000Z</updated>
        <summary type="html"><![CDATA[<p>你需要几个好的「管家」来管理你的电脑 - Homebrew 就是其中一个。</p>
]]></summary>
        <content type="html"><![CDATA[<p>你需要几个好的「管家」来管理你的电脑 - Homebrew 就是其中一个。</p>
<!-- more -->
<h2 id="介绍">介绍</h2>
<p>As you know，macOS 是一个类 Unix 平台，能够方便地配置各种需要的开发环境，前端、后台、移动端的开发都可以在 macOS 上进行。在开发的过程中，常常需要开发者安装各种各样的第三方工具才能够完成相应的开发任务，比如Python、MySQL。然而，不同于 Ubuntu 自带有 apt-get，在 macOS 上一直没有原生的包管理工具，这也为开发者使用第三方库带来了一定的困难。另一方面，有时候采用官方的安装方法，可能会与系统自身的文件系统纠缠在一起，如果未来某天想要彻底删除第三方库的话，可能会异常繁琐，甚至一不小心就删除了系统文件，得不偿失。Homebrew 的诞生解决了这一问题，通过 Homebrew 可以方便地进行包管理，并且不会对系统文件产生影响。本文将对这个神奇的工具进行一些简单的介绍。</p>
<blockquote>
<p>一些趣闻：听说 Homebrew 的作者因为面试的时候没办法手写二叉树被拒了。</p>
</blockquote>
<h3 id="什么是homebrew">什么是Homebrew</h3>
<p>正如官方宣传的那样（官网链接<a href="https://brew.sh">戳这里</a>），Homebrew 是macOS 上缺失已久的包管理工具，它是一个命令行（CLI）程序，提供了类似Ubuntu 上的 apt-get 功能，通过简单的命令，就能够方便地进行第三方库的安装、更新与卸载操作，并且避免了与系统文件产生冲突的弊端。</p>
<h3 id="为什么要使用homebrew">为什么要使用Homebrew</h3>
<p>作为一名开发者，与第三方库打交道是再正常不过的事情了。在 macOS 平台上，使用第三方库的方式主要包括：源码编译、官网提供 pkg 文件、使用包管理工具。使用源码编译能够完全掌握安装流程，还能够按照自己的需求修改源码进行个性化，但是步骤比较繁琐，需要的编译工具较多，并且容易出错。使用官方提供的 pkg 文件简化了安装步骤，比如 Python 就提供了官方 pkg 安装包，直接双击打开像安装应用程序一样即可，但是采用这种方式进行安装非常容易与系统文件混在一起，卸载的时候就是一场噩梦了。虽然通过 pkgutil 可以查看安装 pkg 的时候创建了哪些文件，但是要想做到完全卸载还是需要手动进行清理。而使用包管理工具则进一步简化了安装步骤，只需使用简单的命令就能方便地安装、更新和删除，在易用性和功能性中间取得一个较好的平衡。</p>
<p>除了 Homebrew 以外，还有其他的 macOS 包管理工具，如 MacPorts 等，感兴趣的话可以自行查阅相关资料。</p>
<h2 id="安装与卸载">安装与卸载</h2>
<p>下面介绍 Homebrew 本身的安装、更新与卸载方法。注意：以下所有代码均在 Terminal 中执行。</p>
<h3 id="安装">安装</h3>
<p>Homebrew 是一个使用 Ruby 编写的程序，而 macOS 自带 Ruby，因此可以使用自带的 Ruby 进行安装。执行下列代码：</p>
<pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<p>如有需要，可以先升级一下系统的 Ruby 版本再安装 Homebrew。</p>
<p>在 macOS 上使用命令行程序需要先安装 Xcode Command Line Tools，可以通过<code>xcode-select install</code>进行安装，按照提示一步一步执行即可。</p>
<p>Homebrew 安装完成后，可以执行<code>brew --help</code>查看 Homebrew 的帮助文档，同时验证是否安装成功。</p>
<h3 id="更新">更新</h3>
<p>执行下列代码以更新 Homebrew：</p>
<pre><code>brew update
</code></pre>
<p>Homebrew 源在国外，更新和下载的时候可能比较慢，稍微等一下就好，也可以采取魔法上网加快下载速度。</p>
<h3 id="卸载">卸载</h3>
<p>执行下列代码以卸载 Homebrew：</p>
<pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;
</code></pre>
<p>Homebrew 的安装目录在<code>/usr/local/Cellar</code>，可以看看有没有什么残留文件。</p>
<h2 id="使用homebrew">使用Homebrew</h2>
<p>下面简单介绍一下如何使用 Homebrew。</p>
<h3 id="库的查找-安装-更新-删除">库的查找、安装、更新、删除</h3>
<p>要查找自己准备安装的库是否支持 Homebrew，可以用 Homebrew 查一下，执行</p>
<pre><code>brew search &lt;formulae&gt;
</code></pre>
<p>执行下列代码以查看库的信息：</p>
<pre><code>brew info &lt;formulae&gt;
</code></pre>
<p>执行下列代码以安装新的库：</p>
<pre><code>brew install &lt;formulae&gt;
</code></pre>
<p>执行下列代码以查看哪些库有新的版本</p>
<pre><code>brew outdated
</code></pre>
<p>执行下列代码对给定的库进行更新，更新后原来的库文件夹会自动删除。</p>
<pre><code>brew upgrade &lt;formulae&gt;
</code></pre>
<p>也可以一次性更新全部</p>
<pre><code>brew upgrade
</code></pre>
<p>执行下列代码删除已安装的第三方库</p>
<pre><code>brew unistall &lt;formulae&gt;
</code></pre>
<p>执行下列代码列出已经成功安装的库</p>
<pre><code>brew list
</code></pre>
<h3 id="添加第三方仓库">添加第三方仓库</h3>
<p>能够直接使用 Homebrew 安装的第三方库都保存在 Homebrew 自己的 Github core 中，Homebrew 还支持从其他仓库进行安装，vapor 就是一个典型的例子。<br>
执行下列代码查看已添加的仓库</p>
<pre><code>brew tap
</code></pre>
<p>执行下列代码添加新的 Github 路径，通常可以通过第三方库的帮助文档获得</p>
<pre><code>brew tap &lt;user/repo&gt;
</code></pre>
<p>如果第三方库不是保存在 Github 上的话，需要给出完整路径</p>
<pre><code>brew tap &lt;user/repo&gt; &lt;URL&gt;
</code></pre>
<p>执行下列代码对 tap 的库进行固定</p>
<pre><code>brew tap-pin &lt;user/repo&gt;
</code></pre>
<p>在 Homebrew 安装第三方库的时候，如存在重名的库，会按照一下的顺序进行安装：</p>
<ol>
<li>pinned taps</li>
<li>core formulae</li>
<li>other taps<br>
如果想要在安装的时候指定使用哪个 tap，可以执行下列代码</li>
</ol>
<pre><code>brew install username/repo/formulae
</code></pre>
<p>如果直接使用<code>brew install</code>，将会按照上述顺序搜索并安装。</p>
<p>执行下列代码移除路径</p>
<pre><code>brew untap &lt;user/repo&gt;
</code></pre>
<blockquote>
<p>关于添加第三方仓库的详细内容请查阅<a href="https://docs.brew.sh/Taps#taps-third-party-repositories">官方文档</a>。</p>
</blockquote>
<h3 id="troubleshooting">TroubleShooting</h3>
<p>执行下列代码清理一下 Homebrew 中的无用文件，</p>
<pre><code>brew cleanup
</code></pre>
<p>执行下列代码对 Homebrew 进行诊断，如果出现 warning，通常来说只要 Homebrew 能正常使用就不用管。</p>
<pre><code>brew doctor
</code></pre>
<h2 id="使用homebrew-cask">使用Homebrew Cask</h2>
<p>Homebrew 能够实现第三方库的便捷安装，那么有没有什么东西能够实现第三方应用程序的便捷安装呢？受 Homebrew 的启发，Homebrew 的作者开发了Homebrew Cask，旨在使用类似于 Homebrew 的方式对第三方应用程序进行管理。</p>
<blockquote>
<p>这里的第三方应用程序指的是没有在 Mac App Store 上架的应用程序。</p>
</blockquote>
<h3 id="什么是homebrew-cask">什么是Homebrew Cask</h3>
<p>Homebrew Cask 可以说是 Homebrew 的一个衍生程序，是为了解决 macOS 上非 Mac App Store 的应用程序的管理问题。在 macOS 上，常见的应用程序安装方式包括：Mac App Store、dmg 文件、pkg 文件。由于桌面端的环境不比移动端，在 macOS 上还无法像 iOS 一样强制用户在 App Store 中安装应用程序，因此可以使用多种方法在 macOS 上安装应用程序。</p>
<ol>
<li>Mac App Store 是苹果官方的安装渠道，在 Mac App Store 上架的软件严格遵循沙盒限制，每个应用程序有自己独立的文件系统，未得到用户允许无法访问其他目录，安全性有很好的保障，但也由于沙盒的原因，在 Mac App Store 上架的应用程序有不少都是阉割版程序，缺失部分核心功能，如 QQ、QQ 音乐、Alfred 等。</li>
</ol>
<p><img src="https://cn.bing.com/th?id=OIP.aOIJ9xxpnDpIsJmHZ-_YrQHaHa&amp;pid=Api&amp;rs=1" alt="MAS"></p>
<ol start="2">
<li>pkg 是早期 Mac 上非常常用的安装方式，在前面也提到过 Python 提供了官方 pkg 安装包，同样它也可以用来安装应用程序。使用 pkg 进行安装只需要双击 pkg 文件，然后按照提示一步一步进行即可，与在 Windows 上安装软件非常相似，使用起来比较方便。但是 pkg 安装存在的问题是应用程序产生的文件可能会与系统文件混在一起，卸载的时候如果不借助第三方清理工具会非常麻烦。常见的使用 pkg 安装的软件有 Adobe 全家、Microsoft Office、Teamviewer 等。有「洁癖」的用户可以使用自带的 pkgutil 或第三方的 UninstallPKG 对 pkg 安装的应用程序进行清理。</li>
</ol>
<p><img src="https://images2015.cnblogs.com/blog/996103/201607/996103-20160721150540919-1448409147.png" alt="PKG"></p>
<ol start="3">
<li>dmg 是目前比较主流的安装方式，应用程序发布者将编译打包好的 .app 文件放在 dmg 文件中，用户安装时直接将 app 拖放到 /Application 目录即可，安装过程简单到令人发指。</li>
</ol>
<p><img src="https://cn.bing.com/th?id=OIP.FcEQ7YbtWC5f7LAV269smQHaD-&amp;pid=Api&amp;rs=1" alt="DMG"></p>
<p>Homebrew Cask 在 dmg 安装的基础上简化了操作，直接通过命令行方便地管理已安装的应用，并且在一定程度上解决了卸载不完全的问题。</p>
<h3 id="软件的查找-安装-更新-删除">软件的查找、安装、更新、删除</h3>
<p>在已经安装好 Homebrew 的前提下，先安装 Homebrew Cask，实际上就是把Homebrew Cask 添加到tap的列表中</p>
<pre><code>brew tap caskroom/cask
</code></pre>
<p>执行下列代码查找能够使用 Homebrew Cask 安装的应用程序</p>
<pre><code>brew cask search &lt;formulae&gt;
</code></pre>
<p>执行下列代码查看应用程序的信息</p>
<pre><code>brew cask info &lt;formulae&gt;
</code></pre>
<p>执行下列代码安装应用程序</p>
<pre><code>brew cask install &lt;formulae&gt;
</code></pre>
<p>安装完成后，应用程序会自动被移动到 /Application 目录，等同于从 dmg 中拖出来放到里面。<br>
执行下列代码删除应用程序</p>
<pre><code>brew cask uninstall &lt;formulae&gt;
</code></pre>
<p>对于应用程序的更新，Homebrew 官方建议采用应用程序自己的更新方法对应用进行更新，如果仍想通过 Homebrew Cask 处理，可以先卸载再重新安装即可。<br>
执行下列代码列出已安装的应用程序</p>
<pre><code>brew cask list
</code></pre>
<p>⚠️需要注意的是，使用 Homebrew Cask 仅仅是替代了「从 dmg 文件中把应用拖到 /Application 」这一步骤，如果安装的应用程序是商业软件，仍然需要输入软件授权码才能继续使用。</p>
<blockquote>
<p>Homebrew Cask 安装的一定是正版软件噢。</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>作为一款优秀的程序，Homebrew 使用起来非常简单，其使用教程都可以在<a href="https://docs.brew.sh">官方文档</a>中查到。Homebrew 的诞生极大提高了开发者们的效率，让他们不再为第三方库的繁琐安装步骤而烦恼。</p>
<p>本文只是简单介绍了Homebrew最简单的应用，更加进阶的使用方法可以自行搜索或查阅官方文档。</p>
<p>另外，除了开发者以外，普通用户有时候也能从中获益。例如，macOS 上的 PSP 模拟器程序 PPSSPP 需要两个库的支持，分别是 sdl2 和 libzip，在官方安装教程中就建议用户使用 Homebrew 安装这两个库，才能够正常运行 PPSSPP。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[绪论 - 如何充分利用 iCloud 和自带 App 实现 Apple 设备之间的互通]]></title>
        <id>https://AndyLuoJJ.github.io/post/xu-lun-ru-he-chong-fen-li-yong-icloud-he-zi-dai-app-shi-xian-apple-she-bei-zhi-jian-de-hu-tong</id>
        <link href="https://AndyLuoJJ.github.io/post/xu-lun-ru-he-chong-fen-li-yong-icloud-he-zi-dai-app-shi-xian-apple-she-bei-zhi-jian-de-hu-tong">
        </link>
        <updated>2019-09-11T08:18:05.000Z</updated>
        <summary type="html"><![CDATA[<p>第一个专题定位为「如何充分利用 iCloud 和自带 App 实现 Apple 设备之间的互通」。本篇是该系列主题的第一篇文章。</p>
]]></summary>
        <content type="html"><![CDATA[<p>第一个专题定位为「如何充分利用 iCloud 和自带 App 实现 Apple 设备之间的互通」。本篇是该系列主题的第一篇文章。</p>
<!-- more -->
<blockquote>
<h3 id="目录">目录</h3>
<ul>
<li>总起</li>
<li>写作动机</li>
<li>拟介绍的内容</li>
<li>结束语</li>
</ul>
</blockquote>
<hr>
<h4 id="总起">总起</h4>
<p>随着苹果公司不断开发出新的硬件设备、推行<s>利于圈钱并</s>迎合中国消费者的营销策略，如今在高校学生的群体里，Apple 设备的占有率可谓是节节攀升，在校园里随处可见 iPhone、iPad、MacBook 的身影。特别是近年来苹果为了抢占教育市场，投入了大量的努力，其中的重头戏自然是 new iPad 对 Apple Pencil 的支持、以及面向开发者开放 <code>ClassKit</code> 框架，以期通过硬件和软件的配合，打造一个专属于 Apple 的教育平台。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/12329372-309b46e843eab9e7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Apple 的「人人能创造」课程"></p>
<p>另外，在 WWDC19 闪亮登场的 iPadOS 同样值得期待，得益于 iOS 的基础，iPadOS 想必能够为用户带来更进一步的生产力，令用户能够在 iPad 上实现轻量办公。对于学生党来说，全新登场的 iPadOS 能够充分发挥他们手上的设备的作用，帮助他们在学习、生活中游刃有余地应对各种不同的使用场景。</p>
<p>然而，抛开 Apple 针对教育市场的一系列措施不说，如今在日常使用中，能够做到充分利用 Apple 生态的人似乎不多——这可能是由于拥有复数台 Apple 设备的人不多，大多数人都仅使用一台 Apple 设备，如 iPhone 或 iPad，而并没有考虑过完全投入到 Apple 的生态环境中。可能对于不少人来说，iPhone、iPad 和 Mac 更多扮演的是轻度办公和休闲娱乐的角色，并不能承担需要高生产力的任务。（想想你买 iPad 真的是为了看课件吗😊）</p>
<p>实际上，iOS 和 macOS 两个平台都自带了许多实用的 App，如果充分利用起来，能够很好地提高我们工作生活的效率，配合 iCloud 能够胜任日常生活中的许多任务。同时，对系统自带 App 的充分利用也能避免安装过多的第三方应用，一方面，为手机存储空间较小的用户带来福音，减缓了空间不足的紧迫感；另一方面，在<strong>信任 Apple 和云上贵州</strong>的前提下，能够在一定程度上更好地保护用户的隐私，避免在无意中向自己不信任的第三方泄漏隐私数据和信息。</p>
<h4 id="写作动机">写作动机</h4>
<p>在笔者所处的校园环境中，手持 iPhone 人很多，拥有 iPad 的人也不少，但是 Mac 的普及率就呈指数下降了，更别提拥有复数 Apple 设备的究竟有多少人了。在拥有一台 Apple 设备的同学们中，有不少都是把 iPhone 看作是一台比较好用的智能手机、iPad 是不错的追剧神器，而并没有把自己的设备看作是提高工作生活效率的工具。对于拥有多台 Apple 设备的同学们来说，能够协调使用自己设备的人似乎也不多，大多数都是将设备的工作范围划出明确的界限，互不干扰的同时自然也失去了相互合作的可能。</p>
<p>至于 iCloud，作为 Apple 开发的一款优秀的云盘，它的功能和独特之处得到了许多人的认可，可惜的是，似乎有不少人只是将 iCloud 作为照片存储和系统备份的「备份盘」，而没有看到 iCloud 最本质的功能——「同步盘」。作为「同步盘」，iCloud 最核心的功能是使不同的 Apple 设备之间能够共享数据，正是由于「同步盘」的特点，才使得「移动办公」成为可能。</p>
<p>在笔者看来，工具是为人服务的，只有合理地使用自己的设备和资源，才能使它们的功能最大化，最大程度地服务于我们的学习和日常生活。因此，笔者希望能够分享一下自己在学习、工作和日常生活中充分利用 iCloud、自带 App 和相关优秀第三方应用的经验，让其他人也能够感受到通过 Apple 设备之间的协作来提升效率、提升幸福感的魅力所在。</p>
<p>笔者自己原本是 MacBook + Android 的配置，自从换了 iPhone，感觉放着 iCloud 这个神奇的工具不用，有点可惜，于是就开始研究如何充分利用手里设备的互通性来提高自己的工作和学习效率。虽然没办法用准确的数字来量化自己效率的提升程度，但是在这个过程中我确实感受到了 iCloud、系统自带 App 和优秀第三方应用带给我的幸福感。</p>
<p>出于各种原因，笔者只拥有 iPhone 和 MacBook Pro 两款 Apple 设备，因此只针对这两个设备的互通谈一谈自己的看法。</p>
<h4 id="拟介绍的内容">拟介绍的内容</h4>
<p>在这一专题中，笔者将介绍在自己的学习和日常生活中，如何通过系统自带 App 和优质第三方应用，提升 Apple 设备之间的互通性，进而提升工作效率。iOS 和 macOS 之间的互通依赖于iCloud，因此介绍的应用可能需要登录 iCloud 以实现各自的功能，建议在安全的网络环境下使用。如果在蜂窝移动网络下使用 iCloud 进行同步，需要注意数据的使用情况。</p>
<p>当然，介绍的应用中有部分自带 App 并不需要使用 iCloud，但却给我的使用带来了更好的体验，这些我也会一并介绍。</p>
<p>说个题外话，Apple 选择云上贵州作为中国的云端服务提供者的举措虽然带来了不少的争议，但经个人亲身体验，确实为中国用户提供了更快的访问速度，也不失为一个方便大众的举措。</p>
<p>拟介绍的自带应用包括但不限于：</p>
<ul>
<li>iBooks</li>
<li>备忘录、提醒事项、照片、日历</li>
<li>Podcast、iTunes、Apple Music</li>
<li>iWork</li>
<li>Safari</li>
</ul>
<p>拟介绍的第三方应用包括但不限于：</p>
<ul>
<li>MarginNote</li>
<li>印象笔记</li>
<li>Xmind Zen</li>
</ul>
<p>注：专题内只介绍笔者使用过的 App，除此之外还有很多其他优秀的应用程序，但由于笔者没有使用过，所以不敢妄加评论，大家可以亲自下载其他的 App 试用，找到适合自己的应用。</p>
<h4 id="结束语">结束语</h4>
<p>「提高工作效率」是一个老生常谈的话题了，然而很少人能够关注电子设备自身的优势，而是转向第三方服务，这本无可厚非，笔者再次也只是分享一下自己使用电子设备的一些经验而已。Anyway，电子设备和技术的进步只是提升了我们的工作效率和生产力，并不能从根本上解决拖延症的问题🙃。</p>
<blockquote>
<p>注：图片摘自<a href="https://www.apple.com/cn/"> Apple 中国官网 </a></p>
</blockquote>
]]></content>
    </entry>
</feed>