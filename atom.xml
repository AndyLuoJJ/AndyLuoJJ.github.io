<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://AndyLuoJJ.github.io</id>
    <title>Andy的小书架</title>
    <updated>2020-01-15T09:16:07.102Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://AndyLuoJJ.github.io"/>
    <link rel="self" href="https://AndyLuoJJ.github.io/atom.xml"/>
    <subtitle>这是我的个人博客，希望能够坚持写一下自己各方面的心得😃</subtitle>
    <logo>https://AndyLuoJJ.github.io/images/avatar.png</logo>
    <icon>https://AndyLuoJJ.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Andy的小书架</rights>
    <entry>
        <title type="html"><![CDATA[我的2019年度总结]]></title>
        <id>https://AndyLuoJJ.github.io/post/wo-de-2019-nian-du-zong-jie</id>
        <link href="https://AndyLuoJJ.github.io/post/wo-de-2019-nian-du-zong-jie">
        </link>
        <updated>2020-01-02T04:00:32.000Z</updated>
        <content type="html"><![CDATA[<p>Unexpected 2019</p>
<p>这是我在 2018 年底完全不会预想到的一年</p>
<p>还算顺利地完成本科毕设，熬过了线性系统，开始了研究生阶段的学习。本科的小伙伴们都各自为了自己的梦想在努力拼搏，希望大家以后能保持联系😊</p>
<figure data-type="image" tabindex="1"><img src="https://AndyLuoJJ.github.io/post-images/1579079123441.JPG" alt="最帅的时刻估计就是停留在毕业照了" loading="lazy"></figure>
<p>很幸运地获得了 WWDC Scholarship，认识来自世界各地的开发者们，在 San Jose 共度全球 iOS 开发者的“春晚”🎉还认识了很多志同道合的伙伴，WWDC 结束之后也还有联系，大家一起加油😄，各位大佬们带带小弟（主要还是自己菜）</p>
<figure data-type="image" tabindex="2"><img src="https://AndyLuoJJ.github.io/post-images/1579079143541.JPG" alt="大中华区的Scholars" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://AndyLuoJJ.github.io/post-images/1579079164087.JPG" alt="大家一起加油哇" loading="lazy"></figure>
<p>非常高兴能够有机会参加各个高校的 iOS Club 学生沙龙活动，和同学们分享一下自己的经历。其实吧我感觉好像也没有什么好分享的😂自己也是个普普通通的大学生（主要还是自己菜x2），也很羡慕能够奖项和 paper 拿到手软的各种大神，希望自己在接下来的一年也能做出能让自己满意的成果吧🤗</p>
<figure data-type="image" tabindex="4"><img src="https://AndyLuoJJ.github.io/post-images/1579079193603.JPG" alt="第一次参加的iOS Club沙龙活动" loading="lazy"></figure>
<p>在江门市中心医院认识了宝哥、业航、昌林还有医院的师兄师姐，一起度过了一段很开心很有意义的研究生活。两位桂林片王有空去找你们玩或者你们来广州我好好招待你们😃还有机会见面的😎</p>
<p>下图就当作是今年给自己的奖励啦😝穷苦学生觉得 iPad 2019 已经足够满足自己要求了，吃性能和屏幕的任务还是交给 MacBook 和 iPhone 处理比较合适，iPad 就安安静静地做好一个深度阅读器吧！</p>
<figure data-type="image" tabindex="5"><img src="https://AndyLuoJJ.github.io/post-images/1579079200141.JPG" alt="心心念的iPad" loading="lazy"></figure>
<p>可能算今年是一个人生的关键点吧。2020加油啦💪</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iWork - 如何充分利用 iCloud 和自带 App 实现 Apple 设备之间的互通]]></title>
        <id>https://AndyLuoJJ.github.io/post/iwork-ru-he-chong-fen-li-yong-icloud-he-zi-dai-app-shi-xian-apple-she-bei-zhi-jian-de-hu-tong</id>
        <link href="https://AndyLuoJJ.github.io/post/iwork-ru-he-chong-fen-li-yong-icloud-he-zi-dai-app-shi-xian-apple-she-bei-zhi-jian-de-hu-tong">
        </link>
        <updated>2019-10-06T08:20:19.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇是专题「如何充分利用 iCloud 和自带 App 实现 Apple 设备之间的互通」的第二篇文章，主要介绍如何在 Apple 平台上使用 iWork 办公套件完成不过于复杂的日常任务。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇是专题「如何充分利用 iCloud 和自带 App 实现 Apple 设备之间的互通」的第二篇文章，主要介绍如何在 Apple 平台上使用 iWork 办公套件完成不过于复杂的日常任务。</p>
<!-- more -->
<blockquote>
<p>目录</p>
<ul>
<li>办公套件的选择
<ul>
<li>Microsoft Office</li>
<li>金山 WPS</li>
<li>iWork</li>
<li>开源解决方案</li>
<li>其他</li>
</ul>
</li>
<li>iWork 在多设备上的联动
<ul>
<li>Pages</li>
<li>Numbers</li>
<li>Keynote</li>
</ul>
</li>
<li>办公套件之外的
<ul>
<li>文本文档工具
<ul>
<li>Markdown</li>
<li>LaTeX</li>
</ul>
</li>
<li>数据处理工具</li>
<li>演示文稿工具</li>
</ul>
</li>
<li>结束语</li>
</ul>
</blockquote>
<h2 id="办公套件的选择">办公套件的选择</h2>
<p>「办公套件」已经不是办公人员的专属了——无论是财务人员、行政人员、办公室白领，抑或是在校学生，都有「制作一份不错的文档<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>」这一需求。在这个计算机如此普及的时代，掌握制作文档的能力可以说是一个不可或缺的技能：一份结构清楚的报告能够向你的上级展现出自己的工作态度，同时也能帮助自己对手头上的工作有一个清晰的认识和规划；一份图文并茂的表格或许能够直观地反映出大数据中蕴藏的商机，从而挖掘出新的用户痛点；一份生动的演示文稿能够向客户展现出产品的特色与优势，为公司在客户中留下一个良好的印象。对于学生来说，完成课程论文、分析实验数据、做好自我劫介绍等，这些任务不但要求他们对自己「要做什么」有一个清晰的认识，还要求他们知道「要怎么做」才能够达到事半功倍的效果。可以说，制作文档的需求存在于每一个使用计算机的用户上。</p>
<p>俗话说「工欲善其事，必先利其器」，要想制作出令人赏心悦目的文档，一套趁手的办公套件是必不可少的——你总不能指望自己能够通过记事本和图片浏览器就能够在规定的时间里完成一份合格的文档吧。目前市面上常见的办公套件选择主要包括以下几种：Microsoft Office、金山 WPS、Apple iWork、开源解决方案、其他。</p>
<h3 id="microsoft-office">Microsoft Office<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></h3>
<figure data-type="image" tabindex="1"><img src="https://AndyLuoJJ.github.io/post-images/1570350292703.jpg" alt="Microsoft Office" loading="lazy"></figure>
<p>大名鼎鼎的微软 Office，办公套件一把手，旗下的 Word、Excel 和 PowerPoint 三件套已经成为了事实上的行业标准，其余所有的办公套件都需要兼容其格式。除了三件套以外，Outlook 是一款不错的邮件客户端，OneNote 是数字笔记本的翘楚，OneDrive 为广大用户带来了云盘的新选择。随着 Office 365 的推出，其平易近人的价格和得天独厚的多平台同步优势，使其受欢迎程度只增不减。</p>
<p>macOS 下同样有对应版本的 Microsoft Office，并且随着版本的更迭，Windows 和 macOS 下制作出来的 Office 文档的兼容性在逐步提高，旧版本中可能存在的一些排版问题，在新版本中或许已经不复存在了。当然排版问题在不同版本之间的 Office 之间就已经存在了的，如果对于格式有一定要求的话，建议采用 PDF 格式在不同平台之间传输。</p>
<h3 id="金山-wps">金山 WPS<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></h3>
<figure data-type="image" tabindex="2"><img src="https://AndyLuoJJ.github.io/post-images/1570350266253.jpg" alt="金山 WPS" loading="lazy"></figure>
<p>同样大名鼎鼎的金山 WPS~~（虽然更多的是因为它的广告）~~，据闻在微软进入中国市场之前垄断了中国的办公套件，并且拥有雷总的技术加持，金山 WPS 在今天依然受到不少人的青睐。可以说，除了 Microsoft Office 本身以外，金山 WPS 是对微软文档格式兼容得最好的一个办公套件，基本上在文本内容和格式上都不会有太大的差异，并且得益于会员制度，金山为用户提供了大量的模板，使得软件的易用程度又上升了一个台阶。</p>
<p>macOS 版本的 WPS 在 2019 年推出了正式版并上架 Mac App Store，在未登录金山账号的情况下对文档只读，并且会经常提示「登录账号以使用更多功能」，登录账号及加入会员计划后能够解锁更多功能。</p>
<h3 id="iwork">iWork<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></h3>
<figure data-type="image" tabindex="3"><img src="https://AndyLuoJJ.github.io/post-images/1570350232646.jpg" alt="iWork" loading="lazy"></figure>
<p>为了能够在自家平台上吸引更多的用户，与竞争（微）对手（软）形成对峙的局面，Apple 开发了自家的 iWork 套件，旗下的 Pages、Numbers 和 Keynote 分别对标 Microsoft Office 的 Word、Excel 和 PowerPoint。在 2013 年 9 月 11 日 iPhone 5s、5c 发布会上，苹果表示 iWork 套件将针对新购买苹果设备的用户开放免费下载，这对于用户来说不失为一个天大的好消息。对于不少关注 Apple 的人来说，Keynote 是其中名气最大的一款软件，毕竟这是 Apple 开发布会的御用幻灯片制作软件，黑白渐变的主题也成为了苹果的一个标志。随着版本的更迭，iWork 的使用体验在逐步上升，对于一些并不过于复杂的任务已经是足够使用的了。</p>
<p>iWork 套件拥有在线版本，可以在 iCloud 网页版中对文档进行查看、编辑操作，就算没有 Mac 也能够在浏览器中体验到 iWork 套件的魅力啦。</p>
<h3 id="开源解决方案">开源解决方案<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></h3>
<figure data-type="image" tabindex="4"><img src="https://AndyLuoJJ.github.io/post-images/1570350312916.jpg" alt="LibreOffice" loading="lazy"></figure>
<p>如果想要使用正版办公套件，又苦于经济成本或平台限制，抑或者希望能够自己对软件的功能作出代码级别的修改，那么开源方案是一个不错的选择。在众多的开源办公套件中，LibreOffice 是笔者认为做得比较不错的，这也是内置在 Ubuntu 系统中的一个默认办公套件。在对标 Microsoft Office 上，LibreOffice 拥有 Writer、Calc、Impress，对于一般的文档编辑任务还是能够胜任的，但是在文件格式的兼容上面还有进步的空间。并且，LibreOffice 还加入了 Draw、Base 和 Math 三个新的功能，能够完成绘图、数据库管理和公式编辑的工作，对于有这方面简单需求的用户来说还是一个不错的选择。</p>
<h3 id="其他">其他</h3>
<p>当然，除了前面介绍的办公套件以外，还可以自行寻找满足需求的软件，构成属于自己的工作流。由于可能涉及到比较多小众的软件，在这里就不多介绍了，读者可以自行在各大搜索引擎中进行搜索相关领域的软件。</p>
<h2 id="iwork-在多设备上的联动">iWork 在多设备上的联动</h2>
<p>由于有 Apple 的加持，无论是在移动端还是在桌面端，iWork 能够有一致的优秀表现，并且与 iCloud 高度集成，方便用户实现对文档的共享和跨设备编辑。下面笔者将介绍自己是如何在日常的学习和生活中使用 iWork 套件满足自己对文档制作的需求的。</p>
<h3 id="pages">Pages</h3>
<p>Pages 对标 Microsoft Office Word，是 iWork 办公套件中的富文本编辑软件。</p>
<p>和大多数的文字处理软件一样，Pages 是一款「所见即所得」的软件，用户在文档中对文字内容、格式作出的任何改变都会直接影响到文档的最终效果，例如对文字的加粗、下划线等。Pages 在操作上与 Word 相差不多，用户可以方便地在右边的格式面板中对文档的格式、布局等作出修改，并在主编辑面板进行文字的编辑。</p>
<figure data-type="image" tabindex="5"><img src="https://AndyLuoJJ.github.io/post-images/1570350338244.jpg" alt="Pages 界面" loading="lazy"></figure>
<p>除了文字以外，在 Pages 中还能插入各种各样的对象，例如图片、视频、形状、表格等，使文档不仅仅是文字的堆砌，增加文档的可读性。除了传统的文字输入外，Pages 还支持插入文本框，改变文本的线性排列结构。得益于这一点，Pages 甚至能够完成海报的制作，结合内置的模板，能够帮助用户快速完成文档的制作。</p>
<p>对于不依赖于模板的文档编辑任务，Pages 能够非常方便、快速地制作出一份符合要求的文档。在我的研究生学习生活中，曾经用 Pages 完成了「线性系统理论」课程的所有书面作业，由于这门课的作业对格式并没有太多的要求，因此使用 Pages 能够帮助我快速完成格式排版，包括列表、图片插入、公式编辑等。使用「段落格式」功能能够快速设置文本的段落层次，使文章的结构一目了然，同时有利于文章目录的制作，在这一点上我认为 Pages 的易用性和用户友好度是高于 Word 的。</p>
<figure data-type="image" tabindex="6"><img src="https://AndyLuoJJ.github.io/post-images/1570350378242.jpg" alt="" loading="lazy"></figure>
<p>在写作业的过程中，不可避免地会遇到需要插入公式的场合。在 Word 中有内置的公式编辑器及第三方的 MathType 可以辅助公式编辑的任务，MathType 也有对应的 Mac 版本。然而，使用 Pages 内置的 LaTeX 公式编辑器同样能够编辑出非常漂亮的公式。选择「插入」-&gt;「方程」即可开始一条公式的编辑，Pages 使用 LaTeX 的语法对公式进行渲染，并且<strong>不需要</strong>额外安装 LaTeX 编译器，一切的渲染任务在 Pages 内部就能够完成。</p>
<figure data-type="image" tabindex="7"><img src="https://AndyLuoJJ.github.io/post-images/1570350388245.jpg" alt="Pages 公式编辑" loading="lazy"></figure>
<p>在移动端上，Pages 与桌面端的差异不大，但为了适配移动端的屏幕大小，不少的功能都被隐藏在了二级菜单中，并且是以图标的形式展现出来的，不熟悉图标的话可能需要多尝试几次才能够知道图标所对应的功能。总体来说，在移动端更适合完成简单的文本编辑和浏览的任务，对于文字格式和布局的调整工作还是建议在桌面端上进行，比较方便。</p>
<h3 id="numbers">Numbers</h3>
<p>Numbers 对标 Microsoft Office Excel，是 iWork 办公套件中的数据处理软件。</p>
<p>相比于 Excel，Numbers 在使用上更加符合普通用户的习惯，常用的功能都已经有相应的实现，只需要。与 Pages 相同，Numbers 同样支持在表格文档中插入其他类型的对象，如文本框、形状、媒体文件等，使表格能够包含更多的信息，这一点在 Excel 中实现元没有 Numbers 简单易用。</p>
<p>尤其是在公式编辑的时候，在单元格中输入 = 号就能开始公式的编辑，并且在右边的面板中会显示内置的常用公式及对应的说明、注释与示例，帮助用户根据自己的需求选择合适的公式。当然，你也能够编写自己的公式来适应实际的工作需求。在单元格的引用方面，Numbers 同样支持工作表<strong>内</strong>及工作表<strong>间</strong>的数据引用，方便用户对数据作进一步的处理。</p>
<figure data-type="image" tabindex="8"><img src="https://AndyLuoJJ.github.io/post-images/1570350408904.jpg" alt="Numbers 公式编辑界面" loading="lazy"></figure>
<p>为了充分发挥 iCloud 的同步优势<s>并且懒得多装一个 App</s>，我选择使用 Numbers 对每月的开支情况进行记录。在 Numbers 的内置模板中有一个「个人预算」的模板，能够对支出的种类、金额和时间进行记录，并用图表的方式统计各个类别的支出情况，并且可以设置预算，从而对自己的支出情况进行管理和控制。在这个记账本中就利用了工作表间的数据引用，「预算」工作表引用了「交易」工作表的数据，将每个类别的支出金额进行合计，并在「预算」工作表中绘制饼图反映各类别的支出占比，提醒自己可以在哪些方面减少自己的开支。</p>
<figure data-type="image" tabindex="9"><img src="https://AndyLuoJJ.github.io/post-images/1570350424912.jpg" alt="Numbers 记账本" loading="lazy"></figure>
<p>对于「记账」这一应用场景，我习惯每当自己花钱的时候，就在手机上记录下这一笔交易，然后在电脑上查看当天的消费 情况，并对自己接下来的开支有一个初步的规划。虽然暂时还没能通过记账发现自己不合理的消费情况，但是养成记账的习惯起码能够知道「自己的钱有没有花在刀刃上」，帮助自己逐渐养成理财的意识和习惯。</p>
<p>相比于 Excel 来说，Numbers 确实还存在很多可以提升的地方，对于专业的数据处理任务来说 Numbers 还是难以胜任的，但是对于普通的任务来说，Numbers 已经游刃有余了。</p>
<h3 id="keynote">Keynote</h3>
<p>Keynote 对标 Microsoft Office PowerPoint，是 iWork 办公套件中的演示文稿软件。</p>
<p>幻灯片的制作可不是简单的「文字 + 图片」的机械组合，而是需要将各个元素有机地结合在一起，设计出具有美感的幻灯片。Keynote 希望用户更关注幻灯片元素之间的美妙组合，而不是把时间浪费在「寻找某个功能的按钮」上。Keynote 强大的对齐工具能够帮助用户快速对文本、图片等内容进行对齐，而在这一点上 PowerPoint 的表现就差一点了。除此之外，Keynote 的模板比 PowerPoint 更加人性化，如果只是进行一个简单的工作汇报，使用 Keynote 不仅省时省力，出来的效果还好，何乐而不为呢？</p>
<figure data-type="image" tabindex="10"><img src="https://AndyLuoJJ.github.io/post-images/1570350438980.jpg" alt="" loading="lazy"></figure>
<p>Keynote 以其出色的动画效果而闻名，其中最强大的莫过于「神奇移动」这一动画效果，它能够平滑地移动前后两张幻灯片中的<strong>同一元素</strong>，对于文字，还可以选择「按字符」进行过渡的效果。Microsoft Office PowerPoint 直到 2016 的版本才出现了类似的动画效果，并且使用起来远没有 Keynote 简单，这应该是 iWork 办公套件中打赢的唯一一场对决吧。</p>
<figure data-type="image" tabindex="11"><img src="https://AndyLuoJJ.github.io/post-images/1570350449629.jpg" alt="Keynote 动画效果选择" loading="lazy"></figure>
<p>在移动端上，当 iPhone 和 Mac 处在同一局域网连接下时，可以将 iPhone 当作翻页笔来使用，控制幻灯片的播放，以后再也不用担心演示现场没有翻页笔的问题啦。除了翻页以外，在 iPhone 上还能够显示激光、笔画等工具，比翻页笔的功能强大的多，在演示的时候能够让用户更加专注于演讲本身而不是幻灯片。毕竟，听众是来听你演讲的，不是来看你做的幻灯片的。</p>
<h2 id="办公套件之外的">办公套件之外的</h2>
<p>工具的使用最终取决于任务的需要。实际上，除了办公套件以外，还有很多优秀的软件能够满足我们对于文档编辑的要求，将这些软件组合起来，何尝不是一个属于自己的「办公套件」呢？</p>
<h3 id="文本文档工具">文本文档工具</h3>
<p>对于文本文档编辑的任务来说，主要的需求是文字的编辑与排版。Word 和 Pages 这类「所见即所得」的富文本编辑器固然能够满足大多数人对文本编辑的需求，但，Markdown 和 LaTeX 是其中两个比较流行的文本文档工具。</p>
<h4 id="markdown">Markdown</h4>
<p>Markdown 是一种轻量级的标记语言，与传统的富文本编辑方式不同，Markdown 是纯文本的编辑方式，通过特定的符号来表示文字的格式，如<s>删除线</s>、<strong>加粗</strong>、<em>斜体</em>等。本文的撰写就是基于 Markdown 完成的。相比于 Word、Pages 等采用的富文本编辑方式，Markdown 能够使写作者更关注于文章的内容而不是格式的修改，从而提高生产力。</p>
<p>由于 Markdown 文档的编辑是以纯文本方式进行的，因此使用任何一个文本编辑器都能够完成 Markdown 文档的撰写，但是如果想要看到 Markdown 渲染后的效果，就需要一款专门的 Markdown 编辑器了。笔者使用的。目前有不少的笔记软件，如印象笔记，已经支持 Markdown 文档的编辑和渲染了，如果不想多安装一个软件的话，可以考虑使用这类软件完成 Markdown 的编写。</p>
<h4 id="latex">LaTeX</h4>
<p>LaTeX 是最好的文字排版软件，没有之一，它以类似于编译代码的方式来实现对文本格式的渲染。与 Markdown 相同，LaTeX 文档实际上也是一个纯文本文件，通过特定的字符和关键字来对格式进行规定，需要专门的 LaTeX 编译器对源文件进行编译、渲染才能够看到最终的效果。</p>
<p>LaTeX 对论文、期刊等对格式有着比较严格的要求的文章撰写中有着得天独厚的优势，但是对于普通用户来说，富文本编辑器和 Markdown 已经足够应付绝大多数的工作了，LaTeX 更加适合专业写作的人员（写文章也逃不了 debug 是什么感受）。</p>
<h3 id="数据处理工具">数据处理工具</h3>
<p>对于数据处理的任务来说，主要的需求是对已有的数据进行整理、处理和可视化等。实际上，除了已有的办公套件以外，用户并没有太多的选择，因为 Excel 已经成为了行业标准，而 Numbers 与 Excel 之间还是存在着非常大的差距的，所以对于专业的数据处理工作来说，Excel 更加靠谱一点。</p>
<p>当然，对于程序员以及硬核用户来说，可以使用更加高阶的方法对数据进行处理，如 Python、Julia、Matlab等。Excel 能够做到的是「用最简单的方式为用户提供最强大的功能」，而如果通过编程的方式对数据进行处理，能够限制你的只有你的想象力了。近年来，Python 在大数据处理领域的热度成指数上升，得益于大量第三方库，使用 Python 或许能够以更加优雅的方式实现对数据的处理和可视化，相比于 Excel 来说，Python 的可玩性只增不减。</p>
<h3 id="演示文稿工具">演示文稿工具</h3>
<p>对于演示文稿来说，主要的需求是生动地展示文档内容，通过动画实现文档内容的突出显示、前后切换等。除了 Keynote 和 PowerPoint 以外，Prezi 也是一个不错的选择，它采用非线性的方式对演示文稿进行展示，在动画切换的效果上比较有特点。由于笔者没有使用过这款软件，感兴趣的读者可以自行感受一下这款软件的魅力所在。</p>
<h2 id="结束语">结束语</h2>
<p>本文介绍了如何在 Apple 设备上使用 iWork 办公套件满足日常的文档编辑需求。相比于 Microsoft Office 来说，iWork 在功能及兼容性上都存在一定的限制，无法像 Microsoft Office 那样成为「事实上的行业标准」。但是，大而全所付出的代价是运行速度较慢、需要一定的经济成本，对于一些普通的文档编辑任务来说，使用 iWork 已经能够满足要求了，如果需要在不同平台上进行兼容，导出为 PDF 才是最好的选择。</p>
<p>那么，你准备好打开 iWork 完成你下一个编辑任务了吗😊</p>
<hr>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>在这里，「文档」的概念并不局限于文本文档，还包括表格、演示文稿等内容。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>图片截取自 https://products.office.com/zh-cn/explore-office-for-home <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>图片截取自 https://www.wps.cn <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>图片截取自 https://www.apple.com/cn/iwork/ <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>图片截取自 https://zh-cn.libreoffice.org <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Apple File System Guide 学习笔记]]></title>
        <id>https://AndyLuoJJ.github.io/post/apple-file-system-guide-xue-xi-bi-ji</id>
        <link href="https://AndyLuoJJ.github.io/post/apple-file-system-guide-xue-xi-bi-ji">
        </link>
        <updated>2019-09-13T10:05:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>由于 iOS 独有的沙箱机制，每一个 iOS app 都有其独立的、与系统和其他 app 隔离开的文件系统，通常来说，开发者只能够对自己 app 的文件系统进行操作，而不能随意访问和操作其他的文件系统。</p>
<p>在iOS中，每个应用各自有着相对独立、完整的文件系统，称为应用程序沙盒，简称沙盒。</p>
<p>任何应用程序的文件访问范围都不允许超出自身沙盒的范围，即无权访问其他应用程序沙盒中的文件。但可以通过获取用户权限来使其他沙盒中的文件发送到当前沙盒中。</p>
<p>文件目录结构与macOS的文件目录结构相类似，通常是通过目录的名称来区分其作用。</p>
<p>为了对文件系统有一个更加深入的了解，本篇笔记基于 Apple 官方文档的学习，总结了 File System 的使用方法。</p>
<h2 id="file-system-basics">File System Basics</h2>
<p>下面简要介绍一下文件系统的基本知识。</p>
<h3 id="常用文件目录">常用文件目录</h3>
<ol>
<li>
<p>Documents: 文档目录，用于存放用户生成的内容、直接与用户打交道的内容，即需要永久保存下来的内容。该目录会通过iTunes和iCloud备份。</p>
</li>
<li>
<p>Documens/Inbox: 文档收件箱目录，用于存放用户允许的从外部应用中获取的文件。可以新建或删除该目录下的文件，但不允许编辑。该目录会通过iTunes和iCloud备份。</p>
</li>
<li>
<p>Library: 资源库目录，用于存放非用户生成的内容，通常是程序或系统需要用到的内部文件。可以生成自己的目录。除了Caches以外的目录会通过iTunes和iCloud备份。</p>
</li>
<li>
<p>tmp: 临时目录，用于存放临时文件，应用程序退出后该目录下的文件会被清空。该目录不会通过iTunes和iCloud备份。</p>
</li>
<li>
<p>其他文件目录：</p>
<ol>
<li>iCloud文件目录，涉及CloudKit的使用</li>
<li>查看模拟器应用沙盒：<code>~/Library/Developer/CoreSimulator/Devices/(check device number)/data/Containers/Data/Application/(check app number)</code></li>
</ol>
</li>
</ol>
<p>图解：<br>
<img src="https://AndyLuoJJ.github.io/post-images/1568369292830.jpg" alt="" loading="lazy"></p>
<h3 id="tips-for-file-system">Tips for file system</h3>
<ol>
<li>
<p>用户数据存放在Documents/中，允许用户新建、删除、编辑。</p>
</li>
<li>
<p>应用程序需要的支持文件存放在Library/Application Support/中，对用户屏蔽，包含各种保证应用程序正常运行的文件。</p>
</li>
<li>
<p>临时数据存放在tmp/中，这些文件不需要做持久化处理，使用完毕后应当删除，iOS系统会不定期清空该目录。</p>
</li>
<li>
<p>缓存文件存放在Library/Caches/中，生命周期比临时文件长，但不如支持文件长，缓存文件用于提高性能及用户体验，避免资源重复加载。iOS系统同样会清空该目录，因此应用程序应能够在需要时重新生成或下载这些缓存文件并保存在同一路径下。</p>
</li>
</ol>
<h2 id="accessing-files-and-directories">Accessing Files and Directories</h2>
<p>下面简要介绍如何访问当前沙箱下的文件及目录。</p>
<h3 id="选择合适的方式来访问文件">选择合适的方式来访问文件</h3>
<p>对于不同类型的文件来说，选择一个合适的方式来访问它们，可以更好地发挥高层 API 的作用，使得文件访问变得更加简单。Apple 对于几种常见的、基本的文件类型提供了标准的访问方法，包括：</p>
<ol>
<li>资源文件，包括Nib（Storyboard）、图片、音频、本地化资源、字符串文件等。这些与代码无关的资源文件通常用来显示本地化内容。一般是使用<code>Bundle.main.path(for resource:of type:)</code>来获取文件路径。</li>
<li>文本文件，包括txt等。文本文件是无结构的ASCII或Unicode字符，通常使用String构造器进行获取。</li>
<li>结构化数据文件：包括XML、plist等。结构化文件通常是在字符串的基础上，使用特定字符集合的数据。XML的解析有特殊的方法。</li>
<li>归档文件</li>
<li>Package</li>
<li>Bundle</li>
<li>代码文件<br>
在标准类型的文件无法满足需求的情况下，可以自定义文件后缀名，以字节流的方式对文件进行读写，能够对文件操作有更加自由的控制。</li>
</ol>
<h3 id="指定文件或目录的路径">指定文件或目录的路径</h3>
<p>通常来说，指定文件或目录路径的方式是使用<code>URL</code>，URL 的创建可以基于 String，即把路径用 String 写出来后，作为 URL init 的参数。有三种方式的URL表示路径：</p>
<ol>
<li>基于路径的URL：file://localhost/Users/andy/Documents/MyFile.txt</li>
<li>文件引用URL：file:///id=6571367.2773272/</li>
<li>基于字符串的URL：/Users/andy/Documents/MyFile.txt<br>
使用 URL 获取路径的另一个好处是能够方便地与 FileManager 结合使用，从而使文件管理变得更加简单有序。关于 FileManager 的使用后面会有进一步的文档学习介绍。</li>
</ol>
<h3 id="在文件系统中对文件进行定位">在文件系统中对文件进行定位</h3>
<p>在访问文件或目录之前，还需要对文件进行定位，常用的方式包括：</p>
<ol>
<li>自己找。</li>
<li>询问用户，可以通过 Open and Save panel 与用户进行交互。</li>
<li>在标准的系统目录下寻找，这又可以分为：
<ol>
<li>在 App Bundle 中寻找：调用<code>Bundle.main.url(for resource:with extension:)</code>获得文件在 App Bundle 中的 URL。</li>
<li>在标准目录中寻找：可以使用<code>FileManager.default.urls(for directory:in domain:)</code>来访问标准目录下的文件 URL，其中第一个参数可以搜索的范围包括 Application Support、Documents、Library 等标准沙箱路径。</li>
</ol>
</li>
<li>使用书签（bookmarks），bookmark 是 URL 的一个属性，是一个定位文件的持久化方法。</li>
</ol>
<h3 id="管理文件和目录">管理文件和目录</h3>
<p>对于文件和目录的管理，无非是创建、复制、移动、删除、隐藏文件等。</p>
<h4 id="创建">创建</h4>
<p>新建目录：使用 FileManager 的 createDirectoryAtURL 或 createDirectoryAtPath 方法在给定路径新建目录。<br>
新建文件：使用 FileManager 的 createFileAtPath:contents:attributes 方法在给定路径新建文件。如果需要将 Data 或 String 的内容写入文件，可以使用 writeToURL:atomically 方法。</p>
<h4 id="复制和移动">复制和移动</h4>
<p>使用 FileManager 的 copyItemAtURL:toURL:error: 或 copyItemAtPath:toPath:error: 方法复制文件或目录；使用 FileManager 的 moveItemAtURL:toURL:error: 或 moveItemAtPath:toPath:error: 方法移动文件或目录。</p>
<blockquote>
<p>文件备份实际上是将文件复制到一个不让用户访问到的位置。</p>
</blockquote>
<p>**注意：**文件的复制和移动操作可能需要较长的时间，并且复制和移动的操作是同步执行的，因此推荐将文件复制和移动操作放到异步线程中执行，避免阻塞主线程。</p>
<h4 id="删除">删除</h4>
<p>使用 FileManager 的 removeItemAtURL:error: 或 removeItemAtPath:error: <strong>永久删除</strong>文件或目录。</p>
<h4 id="隐藏文件">隐藏文件</h4>
<p>在 macOS 中，隐藏文件是文件名以.开头的文件，默认不会显示出来，但是用户仍然有办法访问到这些文件。对于 iOS，通常来说没有必要设置隐藏文件。</p>
<h2 id="filemanager-文档解读">FileManager 文档解读</h2>
<p>Apple 推荐的文件管理方式是使用 FileManager 进行文件路径的获取、访问、修改等操作。下面结合 FileManager 的<a href="https://developer.apple.com/documentation/foundation/filemanager">官方文档</a>进行学习，并对一些比较重要和常用的方法与属性进行记录。</p>
<h3 id="概要">概要</h3>
<p>FileManager 是 Foundation 框架中的类，帮助开发者更加方便地与文件系统进行交互，其继承于 NSObject。通过 FileManager，开发者可以对文件和目录进行定位、创建、复制、移动等操作，也可以获取到文件和目录的信息并修改它们的一些属性。<br>
定位文件可以使用 URL 或 String，更推荐 URL 是因为它可以用一种更加稳健的方式表示路径，并且 URL 提供了书签（bookmark）进一步简化文件的访问。<br>
在使用 FileManager 对文件进行操作时，具体的操作可以由遵循 FileManagerDelegate 委托来定义，通过委托模式进行实现解耦和自定义。<strong>注意在这种情况下，在执行文件操作的时候需要创建一个新的 FileManager 实例，设置其代理，然后用这个新的实例对操作进行初始化（即避免使用 share 的 FileManager 实例）</strong><br>
在 iOS 5.0 和 macOS 10.7 以后版本的系统中，还可以直接使用 FileManager  对 iCloud 中的文件进行管理，发挥 iCloud 强大的同步特性。<br>
对于多线程，share 的 FileManager 实例的方法可以安全地在多个线程中调用，即耗时操作可以放在异步线程中异步执行。<br>
对于 macOS app，FileManager 能够，这里记录的主要是在 iOS 上的使用方法，更多的使用请查阅<a href="https://developer.apple.com/documentation/foundation/filemanager">官方文档</a></p>
<h3 id="创建-filemanager-实例">创建 FileManager 实例</h3>
<p>有两种方法：</p>
<ol>
<li><code>init(authorization)</code>，初始化方法，参数为 NSWorkspace.Authorization 类型的实例，用户给予的访问文件的权限。</li>
<li><code>class var `default`</code>：FileManager 单例，app 内共享的 FileManager</li>
</ol>
<h3 id="访问用户目录">访问用户目录</h3>
<p>实际上需要访问的是用户目录和临时目录：</p>
<ul>
<li><code>func NSHomeDirectory() -&gt; String</code>：当前用户的主目录，全局函数</li>
<li><code>func NSUserName() -&gt; String</code>, <code>func NSFullUserName() -&gt; String</code>：当前用户的用户名。这两个方法是全局方法，不是 FileManager 的类方法。</li>
<li><code>var temporaryDirectory: URL</code>：当前用户的临时目录。</li>
</ul>
<h3 id="定位系统目录">定位系统目录</h3>
<ul>
<li><code>func url(for: FileManager.SearchPathDirectory, in: FileManager.SearchPathDomainMask, appropriateFor: URL?, create: Bool) -&gt; URL</code></li>
<li><code>func urls(for: FileManager.SearchPathDirectory, in: FileManager.SearchPathDomainMask) -&gt; [URL]</code>：</li>
<li><code>func NSSearchPathForDirectoriesInDomains(FileManager.SearchPathDirectory, FileManager.SearchPathDomainMask, Bool) -&gt; [String]</code><br>
上述三个方法都能够返回给定路径枚举的路径。</li>
</ul>
<h3 id="列举目录内容">列举目录内容</h3>
<ul>
<li><code>func contentsOfDirectory(atPath:) -&gt; [String]</code>；：搜索给定的路径，并给出路径下包含的内容的路径</li>
</ul>
<h3 id="创建-删除-替换-移动-复制">创建、删除、替换、移动、复制</h3>
<ul>
<li><code>func createFile(atPath:contents:attributes:) -&gt; Bool</code>：在给定路径下、使用给定的属性键值对，利用给定的Data创建文件。</li>
<li><code>func createDirectory(atPath:withIntermediateDirectories:attributes:)</code>, <code>func createDirectory(at:withIntermediateDirectories:attributes:)</code>：在给定路径下创建目录。</li>
<li><code>func removeItem(at:)</code>, <code>func removeItem(atPath:)</code>：删除给定路径的文件或目录。</li>
<li><code>func replaceItemAt(:withItemAt:backupItemName:options:)</code>： 将某个路径下的项目替换成另一路径下的项目，允许创建备份，并且可以保证没有数据丢失。</li>
<li><code>func copyItem(at:to:)</code>, <code>func copyItem(atPath:toPath:)</code>：：将某一路径下的项目复制到另一路径。</li>
<li><code>func moveItem(at:to:)</code>, <code>func moveItem(atPath:toPath:)</code>：将某一路径下的项目移动到另一路径。<br>
以上就是在普通的开发任务中比较常用的文件操作方法。</li>
</ul>
<blockquote>
<p>对于需要登录的 app，如果不想采用 Core Data 来进行用户数据的存储，可以考虑将用户的信息以文件的形式保存在本地。当然，如果这么做还需要考虑到文件的加密等安全措施。</p>
</blockquote>
<hr>
<p><em>Example code:</em></p>
<pre><code class="language-swift">// This code shows how to combine FileManager 
// and NSSearchPathForDirectoriesInDomains to deal with file system.
// create a file manager instance that manages the files in sandbox.
let manager = FileManager.default
// specify the location of directory, using a string-related enum.
let path = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)
// grasp the first element of the array, which is the path string.
let testDir = path[0]
print(testDir)
// add more details to system path.
let filePath = testDir + &quot;/folder1&quot;
do {
    // call the responding methods to create directories, files, or
    // access them.
    try manager.createDirectory(atPath: filePath, withIntermediateDirectories: false, attributes: nil)
    print(&quot;succeed&quot;)
} catch {
    // deal with errors in the above operation.
    print(&quot;error&quot;)
}
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[macOS 使用 pyenv 和 virtualenv 搭建 python 工作环境]]></title>
        <id>https://AndyLuoJJ.github.io/post/macos-shi-yong-pyenv-he-virtualenv-da-jian-python-gong-zuo-huan-jing</id>
        <link href="https://AndyLuoJJ.github.io/post/macos-shi-yong-pyenv-he-virtualenv-da-jian-python-gong-zuo-huan-jing">
        </link>
        <updated>2019-09-13T09:53:13.000Z</updated>
        <summary type="html"><![CDATA[<p>人生苦短，我在 Mac 上用 python。</p>
]]></summary>
        <content type="html"><![CDATA[<p>人生苦短，我在 Mac 上用 python。</p>
<!-- more -->
<h2 id="介绍">介绍</h2>
<p>macOS 自带 python2.7，但是为了更好地进行 python 的开发，最好是安装 python3 进行适配。然而，有时候我们需要在不同的项目中使用不同版本的 python，如果直接采用官网的 pkg 文件安装的话不免会产生冲突，而且也没有办法管理。为此，本文通过使用 Homebrew 和相应的工具包来搭建 python 工作环境。</p>
<blockquote>
<p>注：对于 Linux 平台，同样也可以使用 pyenv 和 virtualenv 对不同版本的 python 和不同的开发环境进行管理，命令基本相同，只是在安装 pyenv 的时候就没办法使用 Homebrew 了，可以使用 Linux 平台上的 apt-get 等包管理工具进行安装。</p>
</blockquote>
<h2 id="准备工作">准备工作</h2>
<ol>
<li>安装 Homebrew</li>
<li>了解如何使用 Terminal</li>
</ol>
<h2 id="使用-pyenv-安装-管理多版本-python">使用 pyenv 安装、管理多版本 python</h2>
<p>pyenv 提供了一个安装、管理多个版本的 python 的工具，可以用类似于 Homebrew 安装包的语句来安装、管理不同版本的 python。</p>
<h3 id="安装-pyenv">安装 pyenv</h3>
<p>安装好 Homebrew 以后，执行<code>brew install pyenv</code>即可完成 pyenv 的安装。<br>
若要卸载 pyenv，执行<code>brew uninstall pyenv</code>即可<br>
安装完成后，还需要在 .bash_profile 中增加以下内容：</p>
<pre><code>export PYENV_ROOT=&quot;${HOME}/.pyenv&quot;

if [ -d &quot;${PYENV_ROOT}&quot; ]; then
  export PATH=&quot;${PYENV_ROOT}/bin:${PATH}&quot;
  eval &quot;$(pyenv init -)&quot;
fi
</code></pre>
<p>这段代码的作用主要是指明 pyenv 的位置， 以便以后可以直接在命令行里面运行 pyenv 命令。 保存在 ~/.bash_profile 文件中是为了每次用户登陆后自动生效。</p>
<h3 id="安装-卸载-python">安装、卸载 python</h3>
<p>完成 pyenv 的安装后，执行<code>pyenv install (python-version)</code>即可安装对应版本号的 python。可通过命令<code>pyenv install --list</code>查看所有可安装的 python 版本，然后替换前面的<code>(python-version)</code>即可。<br>
安装完毕后，执行<code>pyenv version</code>查看当前 python 版本。<code>pyenv versions</code>查看已安装的 python 版本，前面有星号的表示当前 python 版本<br>
安装好的 python 实际路径为<code>~/.pyenv/versions</code></p>
<h3 id="切换-python-版本">切换 python 版本</h3>
<p>使用<code>pyenv global (python-version)</code>切换全局 python 版本，<code>pyenv global system</code>切换回系统自带 python，<code>pyenv local (python-version)</code>切换当前目录的 python 版本。</p>
<h2 id="使用-pyenv-virtualenv-创建-管理多个不同的-python-工作区">使用 pyenv-virtualenv 创建、管理多个不同的 python 工作区</h2>
<p>有时候我们需要在不同的项目工程中使用不同版本的 python，virtualenv 就是一个能够创建隔离的 python 环境的工具，这本来是一个 python 包，本节将介绍一个基于 pyenv 的插件：pyenv-virtualenv。下一节介绍如何单独使用 virtualenv 管理工作区。</p>
<h3 id="安装-pyenv-virtualenv">安装 pyenv-virtualenv</h3>
<p>使用 Homebrew 安装：<code>brew install pyenv-virtualenv</code></p>
<h3 id="创建隔离的工作环境">创建隔离的工作环境</h3>
<p>创建工作环境：<code>pyenv virtualenv (python-version) (workspace-name)</code>。<br>
上面这句命令使用给定的python版本创建了一个名为workspace-name的工作环境，目录的实际路径为<code>~/.pyenv/versions/(python-version)/envs</code>，同时会在<code>~/.pyenv/versions</code>中创建一个对应的软链接，指向相应的目录。</p>
<h3 id="切换不同的工作环境">切换不同的工作环境</h3>
<p>激活环境：<code>pyenv activate (workspace-name)</code><br>
退出环境：<code>pyenv deactivate</code><br>
在这个隔离的虚拟环境中，可以使用 pip 安装需要的包，而不会影响到其他的 python 版本。但是可能会在 home directory 下创建一些隐藏目录（如 keras、matplotlib、jupyter 等）。</p>
<h3 id="删除工作环境">删除工作环境</h3>
<p>只需要把工作环境的目录删除掉就可以删除对应的工作环境了</p>
<blockquote>
<p>顺带一提的是，使用 PyCharm 等 IDE 的时候，会自动检测出项目是否使用了 virtualenv ，因此直接在 IDE 中运行代码即可，不需要激活虚拟环境。</p>
</blockquote>
<h2 id="单独使用-virtualenv-管理工作区">单独使用 virtualenv 管理工作区</h2>
<p>virtualenv 原本是一个可以通过 pip 安装的 python 包，上面的 pyenv-virtualenv 是以插件的形式，配合 pyenv 进行使用的。如果已经用其他的方法安装了 python，如官网 pkg、Homebrew 等，还可以单独使用 virtualenv 进行管理。效果与前面完全相同，只是使用的命令有所改变。</p>
<h3 id="安装-virtualenv">安装 virtualenv</h3>
<p>使用 pip 安装：<code>pip install virtualenv</code></p>
<h3 id="创建隔离的工作环境-2">创建隔离的工作环境</h3>
<p>创建工作环境：<code>virtualenv (python-path) (workspace-directory) --option</code><br>
上述命令中，需要指定工作环境使用 python 的 python 解释器路径，然后会复制一份到工作环境中，并且还需要指定工作环境的实际路径；option 选项则可以指定是否将原来的包一并复制过去，如果使用<code>--no-site-packages</code>则不复制,<code>pyenv global (python-version)</code> 仅复制系统系统包，默认是复制的。</p>
<h3 id="切换工作环境">切换工作环境</h3>
<p>首先 cd 到 workspace-directory。<br>
激活环境：<code>source bin/activate</code><br>
退出环境：<code>deactivate</code><br>
激活后就可以在隔离的工作环境中使用 pip 安装需要的包了。</p>
<h3 id="删除隔离的工作环境">删除隔离的工作环境</h3>
<p>同样是删除 workspace-directory 即可删除工作环境。</p>
<h2 id="总结">总结</h2>
<p>说了这么多，使用这种办法来安装和管理无非是为了能够更好地掌控安装过程，并且安装、卸载也非常干净简洁。在搭建好 python 工作环境以后，马上开始着手干活才是最重要的，不能为了使用工具而使用工具，这样就本末倒置了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift Package Manager - Swift自带的包管理器]]></title>
        <id>https://AndyLuoJJ.github.io/post/swift-package-manager-swift-zi-dai-de-bao-guan-li-qi</id>
        <link href="https://AndyLuoJJ.github.io/post/swift-package-manager-swift-zi-dai-de-bao-guan-li-qi">
        </link>
        <updated>2019-09-13T09:41:12.000Z</updated>
        <summary type="html"><![CDATA[<p>WWDC19 为 Swift 带来了新的活力 - Swift Package Manager 将促使 Swift 向其他领域的发展迈出重要的一步。</p>
]]></summary>
        <content type="html"><![CDATA[<p>WWDC19 为 Swift 带来了新的活力 - Swift Package Manager 将促使 Swift 向其他领域的发展迈出重要的一步。</p>
<!-- more -->
<p>为了能够更方便地通过 Swift 创建可执行文件及第三方库，Apple 提供了 Swift Package Manager 来帮助开发人员管理项目，以便复用代码及简化管理流程。</p>
<h3 id="相关概念">相关概念</h3>
<h4 id="package">Package</h4>
<p>Package 包含一系列的 Swift 源文件和一个名为<code>Package.swift</code>的配置文件。配置文件中定义了Package 的名称和内容。一个 Package 可以产生多个 target，而每个 target 唯一对应一个 product 及一个或以上的 dependency。</p>
<p>Target 是 Package 产生的目标，一个 Package 可以有多个目标。每个 Target 都产生一个输出，这个输出可以是空的、可执行文件、库、系统模块，并且每个 target 都可以是基于其他的库进行开发的，这些库就称为这个target 的依赖（dependency）。</p>
<h4 id="module">Module</h4>
<p>Swift 将 Package 中的文件以 module（模块）的形式进行管理，每一个 module 都规定了一个命名空间（namespace），并且通过访问控制符，可以控制 module 内部的代码是否可以被 module 外的代码所访问。</p>
<p>每一个工程都可以将它需要用到的代码全部包含到一个 module 中，也可以将其他的 module 导入（import）进来，作为自己的依赖（dependency）。<strong>注意 target 的依赖和工程的依赖稍有不同，所有 target 的依赖构成的集合才是工程的依赖。</strong></p>
<p>通过将能够解决某一特定类型的问题的代码封装成一个独立的模块，可以使代码复用到其他场景中。例如，用于解析JSON数据的模块可以用到所有需要与网络数据打交道的项目中，这样就不需要重新自己写相应功能的代码了。<strong>对这类代码的要求是必须独立于项目之外，具有类似于函数的特性。</strong></p>
<p>SPM 允许我们从本地或者网络上获取到我们所需要的其他第三方 module。</p>
<h4 id="library">Library</h4>
<p>Library 类似于开发中的库，即工程本身不产生可执行文件，而是作用一个通用的功能模块，可以被导入到其他项目中发挥作用。</p>
<h4 id="dependency">Dependency</h4>
<p>如果想要能够复用代码，就需要指定自己的工程<em>依赖</em>于哪些外部的代码，因为自己的工程能否正常运行取决于这些外部代码是否正常工作，因此这些外部代码也被称为依赖（dependency）。</p>
<h3 id="简单使用方法">简单使用方法</h3>
<p>下面简单介绍一下SPM的使用方法。</p>
<h4 id="创建项目">创建项目</h4>
<p>在需要创建项目的目录中执行<code>swift package init</code>以创建一个新的 Swift 项目。</p>
<pre><code>$ mkdir testProgram
$ cd testProgram
$ swift package init (--type library/executable/empty/system module)
</code></pre>
<p>type可以有四种类型：</p>
<ul>
<li>library: 创建库</li>
<li>executable: 创建可执行文件</li>
<li>empty:创建空项目</li>
<li>system module:创建系统模块项目<br>
默认创建的是library。</li>
</ul>
<p>另外，在创建好项目后，为了能够充分发挥Xcode强大的功能，还可以生成 Xcode project 以便在 Xcode 中编辑、调试代码。cd 到项目目录后，执行<code>swift package generate-xcodeproj</code>就可以创建对应的 Xcode project 了。</p>
<blockquote>
<p>目前只能在 Xcode 中实现代码编辑，暂时没有找到能够充分发挥 Xcode 功能的办法，编译和运行都需要回到 Terminal 进行。</p>
</blockquote>
<h4 id="添加外部模块">添加外部模块</h4>
<p>如前所述，<code>Package.swift</code>是项目的配置文件，模版代码如下。</p>
<pre><code class="language-swift">// swift-tools-version:4.2
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: &quot;testProgram&quot;,
    products: [
        // Products define the executables and libraries produced by a package, and make them visible to other packages.
        // A package can produce multiple executables and libraries.
        .library(
            name: &quot;testProgram&quot;,
            targets: [&quot;testProgram&quot;]),
        .executable(
            name: &quot;MainExecutable&quot;,
            targets: [&quot;MainExecutable&quot;])
    ],
    dependencies: [
        // Dependencies declare other packages that this package depends on.
        // .package(url: /* package url */, from: &quot;1.0.0&quot;),
    ],
    targets: [
        // Targets are the basic building blocks of a package. A target can define a module or a test suite, and of course an executable.
        // Targets can depend on other targets in this package, and on products in packages which this package depends on.
        .target(
            name: &quot;testProgram&quot;,
            dependencies: []),
        .testTarget(
            name: &quot;testProgramTests&quot;,
            dependencies: [&quot;testProgram&quot;]),
    ]
)

</code></pre>
<p>该模版代码创建了一个Package实例，并通过构造参数来指定项目的name、product、target和dependency。各字段作用如下：</p>
<ul>
<li>name:指定项目名称</li>
<li>products:指定项目生成的东西，可以是library或者executable，同一个项目可以生成多个library或executable。</li>
<li>dependencies: 指定项目所使用的依赖库及其URL、版本等信息。</li>
<li>targets:指定项目生成的目标，</li>
</ul>
<p>若要添加开源代码，在.dependency中添加：</p>
<pre><code class="language-swift">.package(url: &quot;open source url&quot;, from: &quot;version number&quot;)
</code></pre>
<p>若要添加本地依赖，在.dependency中添加：</p>
<pre><code class="language-swift">.package(path:&quot;local path&quot;)
</code></pre>
<p>可以添加多个依赖，并且用上述类似的方法还可以创建多个products和targets。</p>
<p>然后在产生的targets中，指定对应的dependency的名称就可以了。</p>
<h4 id="发布library">发布library</h4>
<p>使用Git将自己创建好的library发布到托管仓库中。</p>
<pre><code>$ git init  // create a new git project
$ git add . // add all files to the stack
$ git remote add origin [github-URL] // add a remote origin in the remote repository
$ git commit -m &quot;Initial Commit&quot; // commit all files in the stack to local repository
$ git tag 1.0.0 // tag the branch
$ git push origin master --tags // push local repository to remote repository
</code></pre>
<p>tag标记的版本号就是其他项目将本项目作为依赖时引用的版本号（from）。对于本地依赖，虽然可以借助git的本地仓库回溯功能进行代码管理，但是在Swift Package Manager中暂时不支持引用本地依赖的版本号。</p>
<h4 id="更新依赖包">更新依赖包</h4>
<p>编辑<code>Package.swift</code>中依赖包的版本信息，然后执行<code>swift package update</code>即可更新需要的依赖包。</p>
<h4 id="创建模块">创建模块</h4>
<p>只需要将<code>Package.swift</code>中的products添加.library就可以创建模块了。每一个Package可以产生多个library，不同的library在Sources目录下以不同名称的目录呈现。</p>
<p>如果生成的library之间有相互关联，则需要在完成一个library的编码工作后，先执行<code>swift build</code>对已有的library进行编译，然后再进行下一个library的编码工作。这有助于以模块化的方式完成library的创建。</p>
<p>注意：对于使用Git开源的代码，需要打上git tag，别人才能够导入对应版本的代码。同样地，对于本地依赖，最好也加上git tag，但是应该不是必须的。</p>
<h3 id="实例结合使用swift-for-tensorflow和swift-package-manager">实例——结合使用Swift for TensorFlow和Swift Package Manager</h3>
<p>为了能够同时使用Swift for TensorFlow和Swift Package Manager进行Swift机器学习项目的管理（个人认为这是比较通用的方法），需要先指定swift路径为SFT的路径，然后使用SPM对项目进行编译、运行等处理。下面macOS上的SFT和SPM为例介绍如何结合使用两者。</p>
<ol>
<li>指定swift路径<br>
在<code>$PATH</code>中指定swift的路径。由于使用了Swift for TensorFLow，因此需要到GitHub仓库中下载对应的swift toolchain，链接<a href="https://github.com/tensorflow/swift">在这里</a>。该swift toolchain中包含了完整的swift编译器，与Xcode自带的toolchain相比多了能够使用TensorFlow的功能。</li>
</ol>
<blockquote>
<p>如果在Linux下进行开发，还需要事先配置好swift的环境，具体教程<a href="https://swift.org/getting-started/">见这里</a>。</p>
</blockquote>
<ol start="2">
<li>创建model对应的library<br>
由于机器学习模型是比较独立的部分，因此最好将其作为一个独立的module，然后将其导入到其他项目中去。接下来要做的创建ML model对应的library。</li>
</ol>
<p>由于例子中MLModel没有使用到第三方库，因此配置文件不需要修改。在<code>./Sources/name</code>中就包含了一个本地module，修改代码为:</p>
<pre><code class="language-swift">import TensorFlow

struct MLPClassifier {
    var w1 = Tensor&lt;Float&gt;(shape: [2, 4], repeating: 0.1)
    var w2 = Tensor&lt;Float&gt;(shape: [4, 1], scalars: [0.4, -0.5, -0.5, 0.4])
    var b1 = Tensor&lt;Float&gt;([0.2, -0.3, -0.3, 0.2])
    var b2 = Tensor&lt;Float&gt;([[0.4]])

    func prediction(`for` x: Tensor&lt;Float&gt;) -&gt; Tensor&lt;Float&gt; {
        let o1 = tanh(matmul(x, w1) + b1)
        return tanh(matmul(o1, w2) + b2)
    }
}
</code></pre>
<p>这里用一个简单的MLP模型作为例子进行展示，自定义了一个MLPClassifierd的类，定义了第一层及第二层的权重和bias，然后使用tanh作为activation function，得到“网络”输出的结果。<br>
通过上述代码就完成了ML model的创建，可以运行swift build看看有没有问题。</p>
<blockquote>
<p>为了加速模型的计算，会有warning说没有用optimization编译。对于小网络来说影响不大，但如果网络结构比较复杂的时候可能会导致训练过慢。暂时好像没有什么办法，唯一想到的解决方案是在release模式下编译，即<code>swift build -c release</code>，release模式默认使用-O进行编译。</p>
</blockquote>
<ol start="3">
<li>创建swift项目<br>
接下来创建使用前面建立好的module的swift项目。新建一个executable的项目，并在Package.swift中添加本地依赖MLModel和用于测试的第三方库SwiftyJSON。</li>
</ol>
<p>测试代码如下：</p>
<pre><code class="language-swift">import TensorFlow
import MLModel

let input = Tensor&lt;Float&gt;([[0.2, 0.8]])
let classifier = MLPClassifier()
let prediction = classifier.prediction(for: input)
print(prediction)
</code></pre>
<p>⚠️：SwiftyJSON要求toolchain版本在4以上，而Swift for TensorFlow的toolchain版本为3，因此暂时没有办法同时使用这两个框架。</p>
<ol start="4">
<li>编译运行<br>
尝试进行编译运行。可以分别执行编译和运行两个步骤，也可以直接运行观察代码运行结果。<br>
编译项目：</li>
</ol>
<pre><code>swift build
</code></pre>
<p>默认的编译环境是<code>debug</code>，可通过<code>-c release</code>的标记，将编译环境切换到<code>release</code>。debug模式默认不开启-O优化，因此为了使Swift for TensorFlow获得最佳性能，建议先在release模式下编译项目，再到指定目录执行link生成的可执行文件。</p>
<p>运行项目：</p>
<pre><code>swift run (executable name)
</code></pre>
<p>也可以找到build生成的可执行文件，然后直接执行。</p>
<blockquote>
<p>如果项目中存在多个可执行文件，需要在<code>swift run</code>命令后增加对应的可执行文件的名称。利用这一特性可以将多个独立的工程汇总在一个package下面，便于管理，但是一个不好的地方是如果修改了一个地方就必须把当前package下的所有swift源文件编译一遍。目前的解决方法是当package规模扩大后，将其中一部分相对独立的功能打包成新的swift package，然后导入进来，这样就不用重新编译导入进来的源码了。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Homebrew - macOS 上完美的包管理器]]></title>
        <id>https://AndyLuoJJ.github.io/post/homebrew-macos-shang-wan-mei-de-bao-guan-li-qi</id>
        <link href="https://AndyLuoJJ.github.io/post/homebrew-macos-shang-wan-mei-de-bao-guan-li-qi">
        </link>
        <updated>2019-09-13T09:15:33.000Z</updated>
        <summary type="html"><![CDATA[<p>你需要几个好的「管家」来管理你的电脑 - Homebrew 就是其中一个。</p>
]]></summary>
        <content type="html"><![CDATA[<p>你需要几个好的「管家」来管理你的电脑 - Homebrew 就是其中一个。</p>
<!-- more -->
<h2 id="介绍">介绍</h2>
<p>As you know，macOS 是一个类 Unix 平台，能够方便地配置各种需要的开发环境，前端、后台、移动端的开发都可以在 macOS 上进行。在开发的过程中，常常需要开发者安装各种各样的第三方工具才能够完成相应的开发任务，比如Python、MySQL。然而，不同于 Ubuntu 自带有 apt-get，在 macOS 上一直没有原生的包管理工具，这也为开发者使用第三方库带来了一定的困难。另一方面，有时候采用官方的安装方法，可能会与系统自身的文件系统纠缠在一起，如果未来某天想要彻底删除第三方库的话，可能会异常繁琐，甚至一不小心就删除了系统文件，得不偿失。Homebrew 的诞生解决了这一问题，通过 Homebrew 可以方便地进行包管理，并且不会对系统文件产生影响。本文将对这个神奇的工具进行一些简单的介绍。</p>
<blockquote>
<p>一些趣闻：听说 Homebrew 的作者因为面试的时候没办法手写二叉树被拒了。</p>
</blockquote>
<h3 id="什么是homebrew">什么是Homebrew</h3>
<p>正如官方宣传的那样（官网链接<a href="https://brew.sh">戳这里</a>），Homebrew 是macOS 上缺失已久的包管理工具，它是一个命令行（CLI）程序，提供了类似Ubuntu 上的 apt-get 功能，通过简单的命令，就能够方便地进行第三方库的安装、更新与卸载操作，并且避免了与系统文件产生冲突的弊端。</p>
<h3 id="为什么要使用homebrew">为什么要使用Homebrew</h3>
<p>作为一名开发者，与第三方库打交道是再正常不过的事情了。在 macOS 平台上，使用第三方库的方式主要包括：源码编译、官网提供 pkg 文件、使用包管理工具。使用源码编译能够完全掌握安装流程，还能够按照自己的需求修改源码进行个性化，但是步骤比较繁琐，需要的编译工具较多，并且容易出错。使用官方提供的 pkg 文件简化了安装步骤，比如 Python 就提供了官方 pkg 安装包，直接双击打开像安装应用程序一样即可，但是采用这种方式进行安装非常容易与系统文件混在一起，卸载的时候就是一场噩梦了。虽然通过 pkgutil 可以查看安装 pkg 的时候创建了哪些文件，但是要想做到完全卸载还是需要手动进行清理。而使用包管理工具则进一步简化了安装步骤，只需使用简单的命令就能方便地安装、更新和删除，在易用性和功能性中间取得一个较好的平衡。</p>
<p>除了 Homebrew 以外，还有其他的 macOS 包管理工具，如 MacPorts 等，感兴趣的话可以自行查阅相关资料。</p>
<h2 id="安装与卸载">安装与卸载</h2>
<p>下面介绍 Homebrew 本身的安装、更新与卸载方法。注意：以下所有代码均在 Terminal 中执行。</p>
<h3 id="安装">安装</h3>
<p>Homebrew 是一个使用 Ruby 编写的程序，而 macOS 自带 Ruby，因此可以使用自带的 Ruby 进行安装。执行下列代码：</p>
<pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<p>如有需要，可以先升级一下系统的 Ruby 版本再安装 Homebrew。</p>
<p>在 macOS 上使用命令行程序需要先安装 Xcode Command Line Tools，可以通过<code>xcode-select install</code>进行安装，按照提示一步一步执行即可。</p>
<p>Homebrew 安装完成后，可以执行<code>brew --help</code>查看 Homebrew 的帮助文档，同时验证是否安装成功。</p>
<h3 id="更新">更新</h3>
<p>执行下列代码以更新 Homebrew：</p>
<pre><code>brew update
</code></pre>
<p>Homebrew 源在国外，更新和下载的时候可能比较慢，稍微等一下就好，也可以采取魔法上网加快下载速度。</p>
<h3 id="卸载">卸载</h3>
<p>执行下列代码以卸载 Homebrew：</p>
<pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;
</code></pre>
<p>Homebrew 的安装目录在<code>/usr/local/Cellar</code>，可以看看有没有什么残留文件。</p>
<h2 id="使用homebrew">使用Homebrew</h2>
<p>下面简单介绍一下如何使用 Homebrew。</p>
<h3 id="库的查找-安装-更新-删除">库的查找、安装、更新、删除</h3>
<p>要查找自己准备安装的库是否支持 Homebrew，可以用 Homebrew 查一下，执行</p>
<pre><code>brew search &lt;formulae&gt;
</code></pre>
<p>执行下列代码以查看库的信息：</p>
<pre><code>brew info &lt;formulae&gt;
</code></pre>
<p>执行下列代码以安装新的库：</p>
<pre><code>brew install &lt;formulae&gt;
</code></pre>
<p>执行下列代码以查看哪些库有新的版本</p>
<pre><code>brew outdated
</code></pre>
<p>执行下列代码对给定的库进行更新，更新后原来的库文件夹会自动删除。</p>
<pre><code>brew upgrade &lt;formulae&gt;
</code></pre>
<p>也可以一次性更新全部</p>
<pre><code>brew upgrade
</code></pre>
<p>执行下列代码删除已安装的第三方库</p>
<pre><code>brew unistall &lt;formulae&gt;
</code></pre>
<p>执行下列代码列出已经成功安装的库</p>
<pre><code>brew list
</code></pre>
<h3 id="添加第三方仓库">添加第三方仓库</h3>
<p>能够直接使用 Homebrew 安装的第三方库都保存在 Homebrew 自己的 Github core 中，Homebrew 还支持从其他仓库进行安装，vapor 就是一个典型的例子。<br>
执行下列代码查看已添加的仓库</p>
<pre><code>brew tap
</code></pre>
<p>执行下列代码添加新的 Github 路径，通常可以通过第三方库的帮助文档获得</p>
<pre><code>brew tap &lt;user/repo&gt;
</code></pre>
<p>如果第三方库不是保存在 Github 上的话，需要给出完整路径</p>
<pre><code>brew tap &lt;user/repo&gt; &lt;URL&gt;
</code></pre>
<p>执行下列代码对 tap 的库进行固定</p>
<pre><code>brew tap-pin &lt;user/repo&gt;
</code></pre>
<p>在 Homebrew 安装第三方库的时候，如存在重名的库，会按照一下的顺序进行安装：</p>
<ol>
<li>pinned taps</li>
<li>core formulae</li>
<li>other taps<br>
如果想要在安装的时候指定使用哪个 tap，可以执行下列代码</li>
</ol>
<pre><code>brew install username/repo/formulae
</code></pre>
<p>如果直接使用<code>brew install</code>，将会按照上述顺序搜索并安装。</p>
<p>执行下列代码移除路径</p>
<pre><code>brew untap &lt;user/repo&gt;
</code></pre>
<blockquote>
<p>关于添加第三方仓库的详细内容请查阅<a href="https://docs.brew.sh/Taps#taps-third-party-repositories">官方文档</a>。</p>
</blockquote>
<h3 id="troubleshooting">TroubleShooting</h3>
<p>执行下列代码清理一下 Homebrew 中的无用文件，</p>
<pre><code>brew cleanup
</code></pre>
<p>执行下列代码对 Homebrew 进行诊断，如果出现 warning，通常来说只要 Homebrew 能正常使用就不用管。</p>
<pre><code>brew doctor
</code></pre>
<h2 id="使用homebrew-cask">使用Homebrew Cask</h2>
<p>Homebrew 能够实现第三方库的便捷安装，那么有没有什么东西能够实现第三方应用程序的便捷安装呢？受 Homebrew 的启发，Homebrew 的作者开发了Homebrew Cask，旨在使用类似于 Homebrew 的方式对第三方应用程序进行管理。</p>
<blockquote>
<p>这里的第三方应用程序指的是没有在 Mac App Store 上架的应用程序。</p>
</blockquote>
<h3 id="什么是homebrew-cask">什么是Homebrew Cask</h3>
<p>Homebrew Cask 可以说是 Homebrew 的一个衍生程序，是为了解决 macOS 上非 Mac App Store 的应用程序的管理问题。在 macOS 上，常见的应用程序安装方式包括：Mac App Store、dmg 文件、pkg 文件。由于桌面端的环境不比移动端，在 macOS 上还无法像 iOS 一样强制用户在 App Store 中安装应用程序，因此可以使用多种方法在 macOS 上安装应用程序。</p>
<ol>
<li>Mac App Store 是苹果官方的安装渠道，在 Mac App Store 上架的软件严格遵循沙盒限制，每个应用程序有自己独立的文件系统，未得到用户允许无法访问其他目录，安全性有很好的保障，但也由于沙盒的原因，在 Mac App Store 上架的应用程序有不少都是阉割版程序，缺失部分核心功能，如 QQ、QQ 音乐、Alfred 等。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://cn.bing.com/th?id=OIP.aOIJ9xxpnDpIsJmHZ-_YrQHaHa&amp;pid=Api&amp;rs=1" alt="MAS" loading="lazy"></figure>
<ol start="2">
<li>pkg 是早期 Mac 上非常常用的安装方式，在前面也提到过 Python 提供了官方 pkg 安装包，同样它也可以用来安装应用程序。使用 pkg 进行安装只需要双击 pkg 文件，然后按照提示一步一步进行即可，与在 Windows 上安装软件非常相似，使用起来比较方便。但是 pkg 安装存在的问题是应用程序产生的文件可能会与系统文件混在一起，卸载的时候如果不借助第三方清理工具会非常麻烦。常见的使用 pkg 安装的软件有 Adobe 全家、Microsoft Office、Teamviewer 等。有「洁癖」的用户可以使用自带的 pkgutil 或第三方的 UninstallPKG 对 pkg 安装的应用程序进行清理。</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://images2015.cnblogs.com/blog/996103/201607/996103-20160721150540919-1448409147.png" alt="PKG" loading="lazy"></figure>
<ol start="3">
<li>dmg 是目前比较主流的安装方式，应用程序发布者将编译打包好的 .app 文件放在 dmg 文件中，用户安装时直接将 app 拖放到 /Application 目录即可，安装过程简单到令人发指。</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://cn.bing.com/th?id=OIP.FcEQ7YbtWC5f7LAV269smQHaD-&amp;pid=Api&amp;rs=1" alt="DMG" loading="lazy"></figure>
<p>Homebrew Cask 在 dmg 安装的基础上简化了操作，直接通过命令行方便地管理已安装的应用，并且在一定程度上解决了卸载不完全的问题。</p>
<h3 id="软件的查找-安装-更新-删除">软件的查找、安装、更新、删除</h3>
<p>在已经安装好 Homebrew 的前提下，先安装 Homebrew Cask，实际上就是把Homebrew Cask 添加到tap的列表中</p>
<pre><code>brew tap caskroom/cask
</code></pre>
<p>执行下列代码查找能够使用 Homebrew Cask 安装的应用程序</p>
<pre><code>brew cask search &lt;formulae&gt;
</code></pre>
<p>执行下列代码查看应用程序的信息</p>
<pre><code>brew cask info &lt;formulae&gt;
</code></pre>
<p>执行下列代码安装应用程序</p>
<pre><code>brew cask install &lt;formulae&gt;
</code></pre>
<p>安装完成后，应用程序会自动被移动到 /Application 目录，等同于从 dmg 中拖出来放到里面。<br>
执行下列代码删除应用程序</p>
<pre><code>brew cask uninstall &lt;formulae&gt;
</code></pre>
<p>对于应用程序的更新，Homebrew 官方建议采用应用程序自己的更新方法对应用进行更新，如果仍想通过 Homebrew Cask 处理，可以先卸载再重新安装即可。<br>
执行下列代码列出已安装的应用程序</p>
<pre><code>brew cask list
</code></pre>
<p>⚠️需要注意的是，使用 Homebrew Cask 仅仅是替代了「从 dmg 文件中把应用拖到 /Application 」这一步骤，如果安装的应用程序是商业软件，仍然需要输入软件授权码才能继续使用。</p>
<blockquote>
<p>Homebrew Cask 安装的一定是正版软件噢。</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>作为一款优秀的程序，Homebrew 使用起来非常简单，其使用教程都可以在<a href="https://docs.brew.sh">官方文档</a>中查到。Homebrew 的诞生极大提高了开发者们的效率，让他们不再为第三方库的繁琐安装步骤而烦恼。</p>
<p>本文只是简单介绍了Homebrew最简单的应用，更加进阶的使用方法可以自行搜索或查阅官方文档。</p>
<p>另外，除了开发者以外，普通用户有时候也能从中获益。例如，macOS 上的 PSP 模拟器程序 PPSSPP 需要两个库的支持，分别是 sdl2 和 libzip，在官方安装教程中就建议用户使用 Homebrew 安装这两个库，才能够正常运行 PPSSPP。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[绪论 - 如何充分利用 iCloud 和自带 App 实现 Apple 设备之间的互通]]></title>
        <id>https://AndyLuoJJ.github.io/post/xu-lun-ru-he-chong-fen-li-yong-icloud-he-zi-dai-app-shi-xian-apple-she-bei-zhi-jian-de-hu-tong</id>
        <link href="https://AndyLuoJJ.github.io/post/xu-lun-ru-he-chong-fen-li-yong-icloud-he-zi-dai-app-shi-xian-apple-she-bei-zhi-jian-de-hu-tong">
        </link>
        <updated>2019-09-11T08:18:05.000Z</updated>
        <summary type="html"><![CDATA[<p>第一个专题定位为「如何充分利用 iCloud 和自带 App 实现 Apple 设备之间的互通」。本篇是该系列主题的第一篇文章。</p>
]]></summary>
        <content type="html"><![CDATA[<p>第一个专题定位为「如何充分利用 iCloud 和自带 App 实现 Apple 设备之间的互通」。本篇是该系列主题的第一篇文章。</p>
<!-- more -->
<blockquote>
<h3 id="目录">目录</h3>
<ul>
<li>总起</li>
<li>写作动机</li>
<li>拟介绍的内容</li>
<li>结束语</li>
</ul>
</blockquote>
<hr>
<h4 id="总起">总起</h4>
<p>随着苹果公司不断开发出新的硬件设备、推行<s>利于圈钱并</s>迎合中国消费者的营销策略，如今在高校学生的群体里，Apple 设备的占有率可谓是节节攀升，在校园里随处可见 iPhone、iPad、MacBook 的身影。特别是近年来苹果为了抢占教育市场，投入了大量的努力，其中的重头戏自然是 new iPad 对 Apple Pencil 的支持、以及面向开发者开放 <code>ClassKit</code> 框架，以期通过硬件和软件的配合，打造一个专属于 Apple 的教育平台。</p>
<figure data-type="image" tabindex="1"><img src="http://upload-images.jianshu.io/upload_images/12329372-309b46e843eab9e7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Apple 的「人人能创造」课程" loading="lazy"></figure>
<p>另外，在 WWDC19 闪亮登场的 iPadOS 同样值得期待，得益于 iOS 的基础，iPadOS 想必能够为用户带来更进一步的生产力，令用户能够在 iPad 上实现轻量办公。对于学生党来说，全新登场的 iPadOS 能够充分发挥他们手上的设备的作用，帮助他们在学习、生活中游刃有余地应对各种不同的使用场景。</p>
<p>然而，抛开 Apple 针对教育市场的一系列措施不说，如今在日常使用中，能够做到充分利用 Apple 生态的人似乎不多——这可能是由于拥有复数台 Apple 设备的人不多，大多数人都仅使用一台 Apple 设备，如 iPhone 或 iPad，而并没有考虑过完全投入到 Apple 的生态环境中。可能对于不少人来说，iPhone、iPad 和 Mac 更多扮演的是轻度办公和休闲娱乐的角色，并不能承担需要高生产力的任务。（想想你买 iPad 真的是为了看课件吗😊）</p>
<p>实际上，iOS 和 macOS 两个平台都自带了许多实用的 App，如果充分利用起来，能够很好地提高我们工作生活的效率，配合 iCloud 能够胜任日常生活中的许多任务。同时，对系统自带 App 的充分利用也能避免安装过多的第三方应用，一方面，为手机存储空间较小的用户带来福音，减缓了空间不足的紧迫感；另一方面，在<strong>信任 Apple 和云上贵州</strong>的前提下，能够在一定程度上更好地保护用户的隐私，避免在无意中向自己不信任的第三方泄漏隐私数据和信息。</p>
<h4 id="写作动机">写作动机</h4>
<p>在笔者所处的校园环境中，手持 iPhone 人很多，拥有 iPad 的人也不少，但是 Mac 的普及率就呈指数下降了，更别提拥有复数 Apple 设备的究竟有多少人了。在拥有一台 Apple 设备的同学们中，有不少都是把 iPhone 看作是一台比较好用的智能手机、iPad 是不错的追剧神器，而并没有把自己的设备看作是提高工作生活效率的工具。对于拥有多台 Apple 设备的同学们来说，能够协调使用自己设备的人似乎也不多，大多数都是将设备的工作范围划出明确的界限，互不干扰的同时自然也失去了相互合作的可能。</p>
<p>至于 iCloud，作为 Apple 开发的一款优秀的云盘，它的功能和独特之处得到了许多人的认可，可惜的是，似乎有不少人只是将 iCloud 作为照片存储和系统备份的「备份盘」，而没有看到 iCloud 最本质的功能——「同步盘」。作为「同步盘」，iCloud 最核心的功能是使不同的 Apple 设备之间能够共享数据，正是由于「同步盘」的特点，才使得「移动办公」成为可能。</p>
<p>在笔者看来，工具是为人服务的，只有合理地使用自己的设备和资源，才能使它们的功能最大化，最大程度地服务于我们的学习和日常生活。因此，笔者希望能够分享一下自己在学习、工作和日常生活中充分利用 iCloud、自带 App 和相关优秀第三方应用的经验，让其他人也能够感受到通过 Apple 设备之间的协作来提升效率、提升幸福感的魅力所在。</p>
<p>笔者自己原本是 MacBook + Android 的配置，自从换了 iPhone，感觉放着 iCloud 这个神奇的工具不用，有点可惜，于是就开始研究如何充分利用手里设备的互通性来提高自己的工作和学习效率。虽然没办法用准确的数字来量化自己效率的提升程度，但是在这个过程中我确实感受到了 iCloud、系统自带 App 和优秀第三方应用带给我的幸福感。</p>
<p>出于各种原因，笔者只拥有 iPhone 和 MacBook Pro 两款 Apple 设备，因此只针对这两个设备的互通谈一谈自己的看法。</p>
<h4 id="拟介绍的内容">拟介绍的内容</h4>
<p>在这一专题中，笔者将介绍在自己的学习和日常生活中，如何通过系统自带 App 和优质第三方应用，提升 Apple 设备之间的互通性，进而提升工作效率。iOS 和 macOS 之间的互通依赖于iCloud，因此介绍的应用可能需要登录 iCloud 以实现各自的功能，建议在安全的网络环境下使用。如果在蜂窝移动网络下使用 iCloud 进行同步，需要注意数据的使用情况。</p>
<p>当然，介绍的应用中有部分自带 App 并不需要使用 iCloud，但却给我的使用带来了更好的体验，这些我也会一并介绍。</p>
<p>说个题外话，Apple 选择云上贵州作为中国的云端服务提供者的举措虽然带来了不少的争议，但经个人亲身体验，确实为中国用户提供了更快的访问速度，也不失为一个方便大众的举措。</p>
<p>拟介绍的自带应用包括但不限于：</p>
<ul>
<li>iBooks</li>
<li>备忘录、提醒事项、照片、日历</li>
<li>Podcast、iTunes、Apple Music</li>
<li>iWork</li>
<li>Safari</li>
</ul>
<p>拟介绍的第三方应用包括但不限于：</p>
<ul>
<li>MarginNote</li>
<li>印象笔记</li>
<li>Xmind Zen</li>
</ul>
<p>注：专题内只介绍笔者使用过的 App，除此之外还有很多其他优秀的应用程序，但由于笔者没有使用过，所以不敢妄加评论，大家可以亲自下载其他的 App 试用，找到适合自己的应用。</p>
<h4 id="结束语">结束语</h4>
<p>「提高工作效率」是一个老生常谈的话题了，然而很少人能够关注电子设备自身的优势，而是转向第三方服务，这本无可厚非，笔者再次也只是分享一下自己使用电子设备的一些经验而已。Anyway，电子设备和技术的进步只是提升了我们的工作效率和生产力，并不能从根本上解决拖延症的问题🙃。</p>
<blockquote>
<p>注：图片摘自<a href="https://www.apple.com/cn/"> Apple 中国官网 </a></p>
</blockquote>
]]></content>
    </entry>
</feed>